{"meta":{"title":"David的文具盒","subtitle":"","description":"","author":"David Fan","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-19T13:23:04.000Z","updated":"2022-04-19T13:35:49.532Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"std::ref详解","slug":"std-ref详解","date":"2022-04-19T13:23:33.000Z","updated":"2022-04-19T13:25:23.332Z","comments":true,"path":"2022/04/19/std-ref详解/","link":"","permalink":"http://example.com/2022/04/19/std-ref%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"std::ref详解用法原理","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"http://example.com/categories/C/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"402. 移掉K位数字","slug":"402-移掉K位数字","date":"2020-11-15T02:40:58.000Z","updated":"2022-04-19T10:50:06.430Z","comments":true,"path":"2020/11/15/402-移掉K位数字/","link":"","permalink":"http://example.com/2020/11/15/402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/","excerpt":"题目描述给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。","text":"题目描述给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 123输入: num = &quot;1432219&quot;, k = 3输出: &quot;1219&quot;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 123输入: num = &quot;10200&quot;, k = 1输出: &quot;200&quot;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 123输入: num = &quot;10&quot;, k = 2输出: &quot;0&quot;解释: 从原数字移除所有的数字，剩余为空就是0。 思路贪心删掉前k个字符中的最大字符，删k次。 错误样例123， k = 1 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string removeKdigits(string num, int k) &#123; int n = num.size(); vector&lt;int&gt; visit(n); auto cmp = [](pair&lt;char, int&gt;&amp; x, pair&lt;char, int&gt;&amp; y) &#123; return x.first &lt; y.first; &#125;; priority_queue&lt;pair&lt;char,int&gt;, vector&lt;pair&lt;char, int&gt;&gt;, decltype(cmp)&gt; q(cmp); int i = 0, cnt = 0; while(i &lt; n || cnt &lt; k) &#123; if(i &lt; k) &#123; q.emplace(num[i], i); &#125; else if(cnt &lt; k) &#123; auto t = q.top(); q.pop(); visit[t.second] = 1; ++cnt; if(i &lt; n) q.emplace(num[i], i); &#125; ++i; &#125; string res; bool flag = false; for(int i = 0;i &lt; n;++i) &#123; if(!visit[i]) &#123; if(!flag &amp;&amp; num[i] != &#x27;0&#x27;) &#123; flag = true; &#125; if(flag) res.push_back(num[i]); &#125; &#125; return res.size() &gt; 0?res:&quot;0&quot;; &#125;&#125;; 贪心1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; int n = num.size(); if(n == 0) return &quot;0&quot;; vector&lt;char&gt; s; int i = 1, j = 0; s.push_back(num[0]); while(i &lt; n) &#123; while(j &lt; k &amp;&amp; !s.empty() &amp;&amp; num[i] &lt; s.back()) &#123; s.pop_back(); ++j; &#125; s.push_back(num[i]); ++i; &#125; while(j &lt; k) &#123; s.pop_back(); j++; &#125; string res; bool flag = false; for(int i = 0;i &lt; s.size();++i) &#123; if(!flag &amp;&amp; s[i] != &#x27;0&#x27;) &#123; flag = true; &#125; if(flag) res.push_back(s[i]); &#125; return res.size() &gt; 0? res: &quot;0&quot;; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"单调栈","slug":"LeetCode/单调栈","permalink":"http://example.com/categories/LeetCode/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"1122. 数组的相对排序","slug":"1122-数组的相对排序","date":"2020-11-14T02:42:03.000Z","updated":"2022-04-19T10:52:32.000Z","comments":true,"path":"2020/11/14/1122-数组的相对排序/","link":"","permalink":"http://example.com/2020/11/14/1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/","excerpt":"题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。","text":"题目描述给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例： 12输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 思路 将arr2放入unordered_set中，可以快速进行arr1的查找 统计arr1中在arr2出现的次数 没有出现的放在另外的vector中 最后进行 桶排序 + 快速排序 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123; // 哈希表用于快速查找 unordered_set&lt;int&gt; s(arr2.begin(), arr2.end()); unordered_map&lt;int, int&gt; m; vector&lt;int&gt; temp; vector&lt;int&gt; ans(arr1.size()); for(auto&amp; num:arr1) &#123; if(s.find(num)!=s.end()) &#123; ++m[num]; &#125; else &#123; temp.push_back(num); &#125; &#125; int i = 0; sort(temp.begin(), temp.end()); for(auto&amp; num:arr2) &#123; for(int j = 0;j &lt; m[num];++j) &#123; ans[i++] = num; &#125; &#125; for(auto&amp; num:temp) &#123; ans[i++] = num; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"哈希","slug":"LeetCode/哈希","permalink":"http://example.com/categories/LeetCode/%E5%93%88%E5%B8%8C/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"哈希","slug":"哈希","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"328. 奇偶链表","slug":"328-奇偶链表","date":"2020-11-13T01:09:51.000Z","updated":"2022-04-19T10:49:24.720Z","comments":true,"path":"2020/11/13/328-奇偶链表/","link":"","permalink":"http://example.com/2020/11/13/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/","excerpt":"328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。","text":"328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 思路双指针 odd指向奇数节点，even指向偶数节点。 交换顺序 1234odd-&gt;next = even-&gt;next;odd = odd-&gt;next;even-&gt;next = odd-&gt;next;even =even-&gt;next; 结束条件 odd为空或even为空，注意循环中的越界检查 需要保存的变量 奇数链表的结尾和偶数链表的起点 奇数链表的结尾可能为空，使用preodd变量暂存 偶数链表的起点为head-&gt;next，使用Listnode *const变量second存储 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr || head-&gt;next-&gt;next==nullptr) return head; ListNode* odd = head, *even = head-&gt;next, *preodd = nullptr; ListNode *const second = even; while(even &amp;&amp; odd) &#123; odd-&gt;next = even-&gt;next; preodd = odd; odd = odd-&gt;next; if(odd==nullptr) break; even-&gt;next = odd-&gt;next; even =even-&gt;next; &#125; if(odd) &#123; odd-&gt;next = second; &#125; else &#123; preodd-&gt;next = second; &#125; return head; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"链表","slug":"LeetCode/链表","permalink":"http://example.com/categories/LeetCode/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"922. 按奇偶排序数组 II","slug":"922-按奇偶排序数组-II","date":"2020-11-12T00:33:38.000Z","updated":"2022-04-19T10:50:54.670Z","comments":true,"path":"2020/11/12/922-按奇偶排序数组-II/","link":"","permalink":"http://example.com/2020/11/12/922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/","excerpt":"题目描述给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。","text":"题目描述给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 123输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 思路模拟使用备用数组暂存，时间复杂度 $O(N)$，空间复杂度 $O(N)$ 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; temp0(n/2), temp1(n/2); int j = 0, k = 0; for(int i = 0;i &lt; n;++i) &#123; if(A[i]&amp;1) &#123; temp1[k++] = A[i]; &#125; else &#123; temp0[j++] = A[i]; &#125; &#125; for(int i = 0;i &lt; n/2;++i) &#123; A[2*i] = temp0[i]; A[2*i + 1] = temp1[i]; &#125; return A; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"514. 自由之路","slug":"514-自由之路","date":"2020-11-11T00:52:46.000Z","updated":"2022-04-19T10:50:35.320Z","comments":true,"path":"2020/11/11/514-自由之路/","link":"","permalink":"http://example.com/2020/11/11/514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/","excerpt":"题目描述视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。 如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。","text":"题目描述视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。 给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。 最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。 旋转 ring 拼出 key 字符 key[i] 的阶段中： 您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。 如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。 示例： 1234567输入: ring = &quot;godding&quot;, key = &quot;gd&quot;输出: 4解释: 对于 key 的第一个字符 &#x27;g&#x27;，已经在正确的位置, 我们只需要1步来拼写这个字符。 对于 key 的第二个字符 &#x27;d&#x27;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。 当然, 我们还需要1步进行拼写。 因此最终的输出是 4。 提示： ring 和 key 的字符串长度取值范围均为 1 至 100； 两个字符串中都只有小写字符，并且均可能存在重复字符； 字符串 key 一定可以由字符串 ring 旋转拼出。 思路贪心每次找最近的，方法是错误的… 动态规划感觉是，但是写不出来。 看了官方题解的状态转移方程，感觉也不是很难（还是自己太菜了😭） 转移方程，key中的第i个字符与ring中的第j个字符最少次数为dp[i][j] 得到状态转移方程 dp[i][j]= \\min_{k∈pos[key[i−1]]}\\{dp[i−1][k]+\\min\\{\\text{abs}(j−k),n−\\text{abs}(j−k)\\}+1\\}其实仔细想想，这个问题的划分好像也不难，子问题比原问题问题规模小1，子问题通过枚举计算。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findRotateSteps(string ring, string key) &#123; vector&lt;vector&lt;int&gt;&gt; pos(26); int l1 = ring.size(), l2 = key.size(); for(int i = 0;i &lt; l1;++i) &#123; pos[ring[i] - &#x27;a&#x27;].push_back(i); &#125; vector&lt;vector&lt;int&gt;&gt; dp(l2, vector&lt;int&gt;(l1,INT_MAX)); // key中第i个字符，j为key[i]在ring中的位置，k为key[i-1]在ring中的位置 for(int i = 0;i &lt; l2;++i) &#123; for(int j: pos[key[i] - &#x27;a&#x27;]) &#123; int min_val = INT_MAX; if(i == 0) &#123; min_val = min(min(abs(j - i), l1 - abs(j - i)) + 1, min_val); &#125; else &#123; for(int k:pos[key[i - 1] - &#x27;a&#x27;]) &#123; min_val = min(min(abs(k - j) , l1 - abs(k - j)) + dp[i-1][k] + 1, min_val); &#125; &#125; dp[i][j] = min_val; &#125; &#125; int res = INT_MAX; for(auto i:pos[key.back() - &#x27;a&#x27;]) &#123; res = min(dp.back()[i], res); &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"}]},{"title":"31. 下一个排列","slug":"31-下一个排列","date":"2020-11-10T00:54:32.000Z","updated":"2022-04-19T10:42:54.640Z","comments":true,"path":"2020/11/10/31-下一个排列/","link":"","permalink":"http://example.com/2020/11/10/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","excerpt":"题目描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1**","text":"题目描述实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1** 思路从不存在入手，如果不存在下一个更大排列，这个排列一定是一个非严格降序(存在等号)排列。 翻转序列，即为题中要求的下一个更大序列。 那么如果存在下一个更大的排列，在原始排列中一定存在一小段严格升序的排列。 从末尾开始遍历排列，找到第一个升序位置，即nums[i] &gt; nums[i-1] 在[i+1,n)的区间上找到比nums[i]大的元素位置j，nums[i]与nums[j]进行交换，这样保证前边是不变的，后边的序列会变大。 [i+1,n)中的序列是降序的，将其进行翻转，使得后边的序列最小，总体的排列即下一个最大的排列。 123456789101112131415161718192021class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), i = n - 2, j = n - 1; if(n==0 || n==1) return; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]) &#123; --i; &#125; if(i != -1) &#123; while(j &gt; i) &#123; if(nums[j] &gt; nums[i]) break; --j; &#125; swap(nums[i], nums[j]); reverse(nums.begin() + i + 1,nums.end() ); &#125; else &#123; reverse(nums.begin(), nums.end()); &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"973. 最接近原点的 K 个点","slug":"973-最接近原点的-K-个点","date":"2020-11-09T00:29:54.000Z","updated":"2022-04-19T10:52:23.050Z","comments":true,"path":"2020/11/09/973-最接近原点的-K-个点/","link":"","permalink":"http://example.com/2020/11/09/973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-K-%E4%B8%AA%E7%82%B9/","excerpt":"题目描述我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。","text":"题目描述我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 示例 1： 1234567输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例 2： 123输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。） 提示： 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 思路维护一个大小为K的大顶堆123456789101112131415161718192021222324252627282930313233class Solution &#123; struct cmp&#123; bool operator()(vector&lt;int&gt;&amp; x1, vector&lt;int&gt;&amp; x2) &#123; return func(x1) &lt; func(x2); &#125; int func(vector&lt;int&gt;&amp; x) &#123; return x[0]*x[0] + x[1]*x[1]; &#125; &#125;; int func(const vector&lt;int&gt;&amp; x) &#123; return x[0]*x[0] + x[1]*x[1]; &#125;;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;, cmp&gt; q; for(const auto&amp; point:points) &#123; if(q.size() &lt; K) &#123; q.push(point); &#125; else &#123; if(func(q.top()) &gt; func(point)) &#123; q.pop(); q.push(point); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; res; while(!q.empty()) &#123; res.push_back(q.top()); q.pop(); &#125; return res; &#125;&#125;; lambda表达式priority_queue的三个模板参数，使用lambda时，要使用decltype解析类型，并在构造函数中传递。 12345template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue; 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; auto func= [](const vector&lt;int&gt;&amp; x) &#123; return x[0]*x[0] + x[1]*x[1]; &#125;; auto cmp =[&amp;func](vector&lt;int&gt;&amp; x1, vector&lt;int&gt;&amp; x2) &#123; return func(x1) &lt; func(x2); &#125;; priority_queue&lt;vector&lt;int&gt;,vector&lt;vector&lt;int&gt;&gt;, decltype(cmp)&gt; q(cmp); for(const auto&amp; point:points) &#123; if(q.size() &lt; K) &#123; q.push(point); &#125; else &#123; if(func(q.top()) &gt; func(point)) &#123; q.pop(); q.push(point); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; res; while(!q.empty()) &#123; res.push_back(q.top()); q.pop(); &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"堆","slug":"LeetCode/堆","permalink":"http://example.com/categories/LeetCode/%E5%A0%86/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"}]},{"title":"962. 最大宽度坡","slug":"962-最大宽度坡","date":"2020-11-08T11:40:40.000Z","updated":"2022-04-19T10:51:54.260Z","comments":true,"path":"2020/11/08/962-最大宽度坡/","link":"","permalink":"http://example.com/2020/11/08/962-%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1/","excerpt":"题目描述给定一个整数数组 A，坡是元组 (i, j)，其中 i &lt; j 且 A[i] &lt;= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。","text":"题目描述给定一个整数数组 A，坡是元组 (i, j)，其中 i &lt; j 且 A[i] &lt;= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。 示例 1： 1234输入：[6,0,8,2,1,5]输出：4解释：最大宽度的坡为 (i, j) = (1, 5): A[1] = 0 且 A[5] = 5. 示例 2： 1234输入：[9,8,1,0,1,9,4,0,4,1]输出：7解释：最大宽度的坡为 (i, j) = (2, 9): A[2] = 1 且 A[9] = 1. 提示： 2 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 50000 思路单调栈+排序+双指针12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxWidthRamp(vector&lt;int&gt;&amp; A) &#123; int n = A.size(), res = 0, i = 0; stack&lt;pair&lt;int, int&gt;&gt; s; s.push(&#123;A[0], 0&#125;); for(i = 1;i &lt; n;++i) &#123; if(A[i] &lt; s.top().first) &#123; s.push(&#123;A[i], i&#125;); &#125; &#125; vector&lt;pair&lt;int, int&gt;&gt; arr(n); for(i = 0;i &lt; n;++i) &#123; arr[i] = &#123;A[i], i&#125;; &#125; sort(arr.begin(), arr.end(), [](pair&lt;int, int&gt; x1, pair&lt;int, int&gt; x2) &#123; return x1.first &lt; x2.first || (x1.first==x2.first &amp;&amp; x1.second &gt; x2.second); &#125;); i = 0; int t = INT_MAX / 2;; while(i &lt; n) &#123; while(!s.empty() &amp;&amp; arr[i].first &gt;= s.top().first ) &#123; t = s.top().second; s.pop(); &#125; res = max(res, arr[i].second - t); ++i; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"单调栈","slug":"LeetCode/单调栈","permalink":"http://example.com/categories/LeetCode/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"单调栈","slug":"单调栈","permalink":"http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"327. 区间和的个数","slug":"327-区间和的个数","date":"2020-11-08T01:46:04.000Z","updated":"2022-04-19T10:49:06.110Z","comments":true,"path":"2020/11/08/327-区间和的个数/","link":"","permalink":"http://example.com/2020/11/08/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"题目描述给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。 说明:最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。 示例: 123输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。","text":"题目描述给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。 说明:最直观的算法复杂度是 O(n2) ，请在此基础上优化你的算法。 示例: 123输入: nums = [-2,5,-1], lower = -2, upper = 2,输出: 3 解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。 思路暴力计算全部区间，$O(n^2)$，超时。 1234567891011121314class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(), res = 0; for(int i = 0;i &lt; n;++i) &#123; long long rangesum = 0L; for(int j = i;j &lt; n;++j) &#123; rangesum += nums[j]; if(rangesum &gt;= lower &amp;&amp; rangesum &lt;= upper) ++res; &#125; &#125; return res; &#125;&#125;; 分治前缀和计算前缀和presum，问题转化为对任意的前缀和val = presum[i] - presum[j](i &gt;= j)落在 [lower, upper] 之间的个数。 计算前缀和注意第一个元素要补0。 若前缀和无序，计算的时间复杂度依旧是$O(n^2)$，若前缀和有序。计算时，可以使用双指针。 问题划分若两个区间[l,m)，[m, r)的前缀和都是有序的，可以利用三指针。 p0指向l， p1指向m，p2指向m p1后移直到presum[p1] - presum[p0] &gt;= lower p2后移直到presum[p2] - presum[p0] &gt; upper p2 - p1则为以p0为起点的区间数量，由于[l, m)是有序的，因此p0后移之后，p1，p2必定后移，不用向前回溯，减少了时间。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int merage(vector&lt;long long&gt;&amp; presum, int l, int r, int lower, int upper) &#123; // 左右右开，[l,r)，区间长度为1时，直接返回0 if(l == r - 1 || l == r) return 0; int m = l + (r - l)/2; int res = 0; res += merage(presum, l, m, lower, upper); res += merage(presum, m, r, lower, upper); int p0 = l, p1 = m, p2 = m; while(p0 &lt; m) &#123; while(p1 &lt; r &amp;&amp; presum[p1] - presum[p0] &lt; lower) ++p1; while(p2 &lt; r &amp;&amp; presum[p2] - presum[p0] &lt;= upper) ++p2; res += p2 - p1; ++p0; &#125; vector&lt;long long&gt; temp(r - l); for(int i = 0, j = l, k = m;i &lt; r - l;++i) &#123; if(j &lt; m &amp;&amp; k &lt; r) &#123; if(presum[j] &lt; presum[k]) temp[i] = presum[j++]; else temp[i] = presum[k++]; &#125; else if(j &lt; m)&#123; temp[i] = presum[j++]; &#125; else &#123; temp[i] = presum[k++]; &#125; &#125; for(int i = 0;i &lt; r - l;++i) &#123; presum[i + l] = temp[i]; &#125; return res; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(); vector&lt;long long&gt; presum(n + 1); for(int i = 0;i &lt; nums.size();++i) &#123; presum[i+1] = presum[i] + nums[i]; &#125; return merage(presum, 0, n + 1, lower, upper); &#125;&#125;; 时间复杂度 $T(N) = 2*T(N/2) + O(N)$ $T(N) = O(NlogN)$ 空间复杂度设空间占用为 $M(N)$，递归调用所需空间为 $M(N/2)$，而合并数组所需空间为 O(N)O(N)，故 M(N) = \\max\\big\\{M(N/2), O(N)\\big\\} = M(N/2) + O(N)$M(N) = O(N)$","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"归并排序","slug":"LeetCode/归并排序","permalink":"http://example.com/categories/LeetCode/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"122. 买卖股票的最佳时机 II","slug":"122-买卖股票的最佳时机-II","date":"2020-11-08T00:53:14.000Z","updated":"2022-04-19T10:45:24.590Z","comments":true,"path":"2020/11/08/122-买卖股票的最佳时机-II/","link":"","permalink":"http://example.com/2020/11/08/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/","excerpt":"题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","text":"题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 思路贪心相邻两天，如果第二天比第一天价格高就第一天买入，第二天卖出。 贪心算法只能用于计算最大利润，计算的过程并不是实际的交易过程。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int res = 0; for(int i = 1;i &lt; n;++i) &#123; if(prices[i - 1] &lt; prices[i]) &#123; res += prices[i] - prices[i-1]; &#125; &#125; return res; &#125;&#125;; 动态规划状态由于不能同时参与多笔交易，因此最多持有1只股票，每天都只有两种状态，持有和不持有。 定义$dp[i][0]$为前$i$天交易完成且第$i$天不持有的最大收益，$dp[i][0]$为前$i$天交易完成且第$i$天持有的最大收益。 转移方程第$i$天不持有股票的最大收益可能和前一天不持有相同，也可能来自前一天持有，第$i$天卖出，因此可以写出如下转移方程。 dp[i][0] = max\\{dp[i-1][0], dp[i-1][1] + prices[i]\\}同理 dp[i][1] = max\\{dp[i-1][1], dp[i-1][0] - prices[i]\\}代码转移方程只有相邻两项有关系，因此可以优化空间。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int hold = -prices[0], nhold = 0, res = 0, n = prices.size(); for(int i = 1;i &lt; n;++i) &#123; auto t = hold; hold = max(hold, nhold - prices[i]); nhold = max(nhold, t + prices[i]); &#125; return nhold; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"LeetCode/贪心","permalink":"http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"}]},{"title":"1356. 根据数字二进制下 1 的数目排序","slug":"1356-根据数字二进制下-1-的数目排序","date":"2020-11-06T00:29:02.000Z","updated":"2022-04-19T10:52:59.380Z","comments":true,"path":"2020/11/06/1356-根据数字二进制下-1-的数目排序/","link":"","permalink":"http://example.com/2020/11/06/1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B-1-%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/","excerpt":"题目描述给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。","text":"题目描述给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。 如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。 请你返回排序后的数组。 示例 1： 1234567输入：arr = [0,1,2,3,4,5,6,7,8]输出：[0,1,2,4,8,3,5,6,7]解释：[0] 是唯一一个有 0 个 1 的数。[1,2,4,8] 都有 1 个 1 。[3,5,6] 有 2 个 1 。[7] 有 3 个 1 。按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2： 123输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]输出：[1,2,4,8,16,32,64,128,256,512,1024]解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3： 12输入：arr = [10000,10000]输出：[10000,10000] 示例 4： 12输入：arr = [2,3,5,7,11,13,17,19]输出：[2,3,5,17,7,11,13,19] 示例 5： 12输入：arr = [10,100,1000,10000]输出：[10,100,10000,1000] 提示： 1 &lt;= arr.length &lt;= 500 0 &lt;= arr[i] &lt;= 10^4 思路统计二进制中1的个数 可以判断末尾是否为1，然后进行向右移位，移位之后数字为0时则没有1。 使用仿函数1234567891011121314151617181920class Solution &#123;public: struct cmp &#123; bool operator()(int x,int y)&#123; return countbit(x) &lt; countbit(y) || (countbit(x) == countbit(y)&amp;&amp;x &lt; y); &#125;; int countbit(int x) &#123; int cnt = 0; while(x) &#123; cnt += x &amp; 1; x = x&gt;&gt;1; &#125; return cnt; &#125;; &#125;; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end(), cmp()); return arr; &#125;&#125;; lambda表达式123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; auto countbit = [](int x) -&gt;int &#123; int cnt = 0; while(x) &#123; cnt += x &amp; 1; x = x&gt;&gt;1; &#125; return cnt; &#125;; auto cmp = [&amp;countbit](int x,int y)-&gt;bool &#123; return countbit(x) &lt; countbit(y) || (countbit(x) == countbit(y)&amp;&amp; x &lt; y); &#125;; sort(arr.begin(), arr.end(), cmp); return arr; &#125;&#125;; 二进制常见操作二进制算法宝典 将二进制中最后的一个1变为0：x &amp; x-1","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"位运算","slug":"LeetCode/位运算","permalink":"http://example.com/categories/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"127. 单词接龙","slug":"127-单词接龙","date":"2020-11-05T00:15:57.000Z","updated":"2022-04-19T10:46:28.200Z","comments":true,"path":"2020/11/05/127-单词接龙/","link":"","permalink":"http://example.com/2020/11/05/127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/","excerpt":"题目描述难度中等501收藏分享切换为英文接收动态反馈 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。","text":"题目描述难度中等501收藏分享切换为英文接收动态反馈 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 123456789输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。 示例 2: 12345678910111213141516171819202122232425262728293031323334353637383940输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。127. 单词接龙给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。说明:如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。示例 1:输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。示例 2:输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。 思路 最少次数，可以用bfs搜索. 使用queue进行bfs搜索，每次对元素的每个位置的单词进行替换 为了快速查找使用unordered_set记录字典中的元素 避免相同节点重复访问，加入访问unordered_set类型的标记vis 当队列为空，且没有找到时，则不存在这样的路径 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; unordered_set&lt;string&gt; s(wordList.begin(), wordList.end()); unordered_set&lt;string&gt; vis; if(s.find(endWord) == s.end()) return 0; queue&lt;string&gt; q; q.push(beginWord); vis.insert(beginWord); int res = 1; while(!q.empty()) &#123; ++res; int n = q.size(); for(int i = 0;i &lt; n;++i) &#123; auto t = q.front(); q.pop(); for(int j = 0;j &lt; t.size();++j) &#123; auto c = t[j]; for(int k = 0;k &lt; 26;++k) &#123; t[j] = &#x27;a&#x27; + k; if(t==endWord) return res; if(s.find(t) != s.end() &amp;&amp; vis.find(t)==vis.end()) &#123; q.push(t); vis.insert(t); &#125; &#125; t[j] = c; &#125; &#125; &#125; return 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"广度优先搜索","slug":"LeetCode/广度优先搜索","permalink":"http://example.com/categories/LeetCode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"BFS","slug":"BFS","permalink":"http://example.com/tags/BFS/"}]},{"title":"emplace_back、push_back杂谈","slug":"emplace-back、push-back杂谈","date":"2020-11-04T11:42:47.000Z","updated":"2022-04-19T10:53:52.910Z","comments":true,"path":"2020/11/04/emplace-back、push-back杂谈/","link":"","permalink":"http://example.com/2020/11/04/emplace-back%E3%80%81push-back%E6%9D%82%E8%B0%88/","excerpt":"emplace_back相当于是直接初始化，根据函数重载找最佳匹配的构造函数。若emplace的是一个完整的对象，则根据函数匹配规则，会自动调用拷贝构造函数。 push_back相当于是拷贝初始化（但是编译器不会进行优化），若push的对象不是完整的对象，则会进行类型转换，转换之后进行添加，添加时会调用拷贝构造函数。 若push_back有右值引用的版本，添加的对象又是一个右值，此时会调用右值版本的移动构造。速度也会很快。","text":"emplace_back相当于是直接初始化，根据函数重载找最佳匹配的构造函数。若emplace的是一个完整的对象，则根据函数匹配规则，会自动调用拷贝构造函数。 push_back相当于是拷贝初始化（但是编译器不会进行优化），若push的对象不是完整的对象，则会进行类型转换，转换之后进行添加，添加时会调用拷贝构造函数。 若push_back有右值引用的版本，添加的对象又是一个右值，此时会调用右值版本的移动构造。速度也会很快。 性能差别 当插入的都是临时对象时，性能没有差别。 如果有移动构造函数，两者都会先调用构造函数，后调用移动构造函数，性能没有差别。 没有，两者都会先调用构造函数，后调用拷贝构造函数，性能没有差别。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; &quot;I am being constructed.\\n&quot;; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; &quot;I am being moved.\\n&quot;; &#125; President(const President&amp; other) : name(other.name), country(other.country), year(other.year) &#123; std::cout &lt;&lt; &quot;I am copy construced.\\n&quot;; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; &quot;emplace_back:\\n&quot;; elections.emplace_back(President(&quot;Nelson Mandela&quot;, &quot;South Africa&quot;, 1994)); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; &quot;\\npush_back:\\n&quot;; reElections.push_back(President(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936)); std::cout &lt;&lt; &quot;\\nContents:\\n&quot;; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was re-elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125;&#125; 运行结果 1234567891011emplace_back:I am being constructed.I am being moved.push_back:I am being constructed.I am being moved.Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. 当插入的时完整的对象时，性能没有差距。 因为push_back()是直接调用拷贝构造函数，emplace_back是按照函数匹配规则调用拷贝构造函数，两者性能相同。 123456789101112131415161718192021int main()&#123; std::vector&lt;President&gt; elections; President temp(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936); std::cout &lt;&lt; &quot;emplace_back:\\n&quot;; elections.emplace_back(temp); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; &quot;\\npush_back:\\n&quot;; reElections.push_back(temp); std::cout &lt;&lt; &quot;\\nContents:\\n&quot;; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was re-elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125;&#125; 12345678910I am being constructed.emplace_back:I am being copy constructed.push_back:I am being copy constructed.Contents:Franklin Delano Roosevelt was elected president of the USA in 1936.Franklin Delano Roosevelt was re-elected president of the USA in 1936. 当push_back一个临时对象，emplace_back不是对象时，例如 1234567std::vector&lt;President&gt; elections;std::cout &lt;&lt; &quot;emplace_back:\\n&quot;;elections.emplace_back(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936);std::vector&lt;President&gt; reElections;std::cout &lt;&lt; &quot;\\npush_back:\\n&quot;;reElections.push_back(President(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936)); 如果对象有移动构造函数，两者性能差距不大，emplace_back会快一点。 push_back会调用一次构造函数。 emplace_back会调用一次构造函数，再调用一次移动构造函数，会慢一点。 如果对象没有移动构造函数，emplace_back会快很多。 push_back会调用一次构造函数。 emplace_back会调用一次构造函数，再调用一次拷贝构造函数，性能差距比较大。 push_back的类别的拷贝构造函数参数如果不是const会出现错误push_back()有四种形式。 1234void push_back( const T&amp; value );constexpr void push_back( const T&amp; value );void push_back( T&amp;&amp; value );constexpr void push_back( T&amp;&amp; value ); 对于非右值时，把对象转换成const，之后会调用拷贝构造函数，当拷贝构造函数不加const时，会尝试把const对象转换为非const对象，引起错误。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"http://example.com/categories/C/STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"57. 插入区间","slug":"57-插入区间","date":"2020-11-04T01:16:53.000Z","updated":"2022-04-19T10:44:26.440Z","comments":true,"path":"2020/11/04/57-插入区间/","link":"","permalink":"http://example.com/2020/11/04/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/","excerpt":"题目描述给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 12输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。","text":"题目描述给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1： 12输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。 思路模拟 判断newInterval是否和interval有重叠 有，进行合并，之后更新的newInterval（不需要插入interval） 没有，判断newInterval是否可以插入 可以，插入newInterval，之后插入interval 不可以，插入interval 合并条件：区间之间存在交叉，interval[1] &gt;= newInterval[0] \\&amp;\\&amp; interval[0] &lt;= newInterval[1] 插入条件：新区间的尾端小于interval的起点，但是可能会插入很多次，因此需要打标记。newInterval[1] &lt; interval[0]&amp;&amp;!flag。 C++代码 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; bool flag = false; // interval和newInterval合并，不能合并就插入 for(const auto&amp; interval:intervals) &#123; // 重合 if(interval[1] &gt;= newInterval[0] &amp;&amp; interval[0] &lt;= newInterval[1]) &#123; newInterval[0] = min(newInterval[0], interval[0]); newInterval[1] = max(newInterval[1], interval[1]); continue; &#125; else if(newInterval[1] &lt; interval[0] &amp;&amp; !flag) &#123; // 不重合, 且是第一次 res.push_back(newInterval); flag = true; &#125; res.push_back(interval); &#125; if(!flag) &#123; res.push_back(newInterval); &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"区间","slug":"区间","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4/"}]},{"title":"1124. 表现良好的最长时间段","slug":"1124-表现良好的最长时间段","date":"2020-11-03T06:03:52.000Z","updated":"2022-04-19T10:52:45.600Z","comments":true,"path":"2020/11/03/1124-表现良好的最长时间段/","link":"","permalink":"http://example.com/2020/11/03/1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/","excerpt":"题目描述给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。","text":"题目描述给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。 所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。 请你返回「表现良好时间段」的最大长度。 示例 1： 123输入：hours = [9,9,6,0,6,6,9]输出：3解释：最长的表现良好时间段是 [9,9,6]。 提示： 1 &lt;= hours.length &lt;= 10000 0 &lt;= hours[i] &lt;= 16 思路准备工作 将$工作时间&gt;8小时$记为1，$&lt;8$记为$-1$，计算前缀和presum。 暴力枚举 使用两根指针，i，j去枚举区间(j,i)，记录最大的i-j，可以进行适度剪枝，but仍旧超时。 时间复杂度：$O(n^2)$，空间复杂度：$O(n)$ c++代码 1234567891011121314151617181920class Solution &#123; public: int longestWPI(vector&lt;int&gt;&amp; hours) &#123; int n = hours.size(); int res = 0; vector&lt;int&gt; presum(n + 1); for(int i = 0;i &lt; n;++i) &#123; presum[i + 1] = presum[i] + (hours[i] &gt; 8? 1 : -1 ); &#125; for(int i = n;i &gt; 0;--i) &#123; for(int j = 0;j &lt; i;++j) &#123; if(i - j &lt;= res) break; if(presum[i] - presum[j] &gt; 0) &#123; res = max(res, i - j); &#125; &#125; &#125; return res; &#125;&#125;; 二分查找（错误） 枚举区间值，l = 0，r = n 前缀和+单调栈+双指针转化之后的问题与962. 最大宽度坡类似，使用单调栈。 双指针也不一定要有序 1234567891011121314151617181920212223242526class Solution &#123;public: int longestWPI(vector&lt;int&gt;&amp; hours) &#123; int n = hours.size(); vector&lt;int&gt; presum(n + 1); for(int i = 0;i &lt; n;++i) &#123; presum[i + 1] = presum[i] + (hours[i] &gt; 8?1:-1); &#125; stack&lt;int&gt; s; int res = 0; for(int i = 0;i &lt;= n;++i) &#123; if(s.empty() || presum[s.top()] &gt; presum[i]) &#123; s.push(i); &#125; &#125; int i = n; while(i &gt;= 0 &amp;&amp; !s.empty()) &#123; while(!s.empty() &amp;&amp; presum[i] &gt; presum[s.top()]) &#123; res = max(res, i - s.top()); s.pop(); &#125; --i; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"单调栈","slug":"LeetCode/单调栈","permalink":"http://example.com/categories/LeetCode/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"单调栈","slug":"单调栈","permalink":"http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"941. 有效的山脉数组","slug":"941-有效的山脉数组","date":"2020-11-03T00:43:22.000Z","updated":"2022-04-19T10:51:14.450Z","comments":true,"path":"2020/11/03/941-有效的山脉数组/","link":"","permalink":"http://example.com/2020/11/03/941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/","excerpt":"题目描述给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 10 &lt; i &lt; A.length - 1 条件下，存在 1i 使得： A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]","text":"题目描述给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 10 &lt; i &lt; A.length - 1 条件下，存在 1i 使得： A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 示例 1： 12输入：[2,1]输出：false 示例 2： 12输入：[3,5,5]输出：false 示例 3： 12输入：[0,3,2,1]输出：true 提示： 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 思路模拟，双指针两根指针从两端找山峰的山顶，找到后判断是否为同一座山峰。 1234567891011121314151617181920212223class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 1, n = A.size(), j = n - 2; while(i &lt; n) &#123; if(A[i] &gt; A[i - 1]) &#123; i++; &#125; else &#123; --i; // 需要--，才是山顶 break; &#125; &#125; while(j &gt;= 0) &#123; if(A[j] &gt; A[j + 1]) &#123; --j; &#125; else &#123; ++j; // 需要++，才是山顶 break; &#125; &#125; return i==j; &#125; &#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"python之并发编程（概念篇）","slug":"python之并发编程（概念篇）","date":"2020-11-02T02:42:07.000Z","updated":"2022-04-19T10:57:01.190Z","comments":true,"path":"2020/11/02/python之并发编程（概念篇）/","link":"","permalink":"http://example.com/2020/11/02/python%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%E7%AF%87%EF%BC%89/","excerpt":"转载自python之并发编程（概念篇） 一.进程 1.什么是进程进程是正在进行的一个过程或者一个任务。而负责执行任务的则是cpu。","text":"转载自python之并发编程（概念篇） 一.进程 1.什么是进程进程是正在进行的一个过程或者一个任务。而负责执行任务的则是cpu。 2.进程与程序的区别程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。同一个程序执行两次是两个进程。 在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。 3.并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，而一个cpu同一时刻只能执行一个任务。 并发：是伪并行，即某个时段看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发） 并行：同时运行，只有具备多个cpu才能实现并行。 单核下，可以利用多道技术，多核中的每个核也都可以利用多道技术（多道技术是针对单核而言的） 有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4， 一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术 而一旦任务1的I/O结束了，操作系统会重新调用它(需知进程的调度、分配给哪个cpu运行，由操作系统说了算)，可能被分配给四个cpu中的任意一个去执行。 4.同步\\异步and阻塞\\非阻塞同步：A调用B，B处理直到获得结果，才返回给A。需要调用者一直等待和确认调用结果是否返回， 然后继续往下执行。异步：A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。调用结果返回时， 会以消息或回调的方式通知调用者。 阻塞：A调用B，A被挂起直到B返回结果给A，A继续执行。调用结果返回前，当前进程挂起不能够处理其他任务，一直等待调用结果返回。非阻塞：A调用B，A不会被挂起，A可以执行其他操作。调用结果返回前，当前进程不挂起， 可以去处理其他任务。 所以，同步异步说的是被调用者结果返回时通知进程的一种通知机制，阻塞非阻塞说的是调用结果返回前进程的状态，是挂起还是继续处理其他任务。 二.线程1.什么是线程线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 2.线程与进程的区别 线程共享创建它的进程的内存空间，进程的内存是独立的 线程可以直接访问其进程的数据段，进程拥有父进程的数据段副本 线程可以直接与其进程的其他线程通信，进程间通信需要通过一个中间代理来实现。 新线程很容易创建，创建新进程需要对父进程实现一次复制。 线程可以控制和操作同一进程里的其他线程，进程只能控制子进程。 对主线程的更改（取消，优先级更改等）可能会影响到进程中其他线程的行为; 对父进程的更改不会影响子进程。 3.多线程多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。 详细的讲分为4点： 多线程共享一个进程的地址空间。 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。 在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python） 三.GIL全局解释器锁每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。它并不是python语言的特性，仅仅是由于历史的原因在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。 由于以前的电脑基本都是单核CPU，多线程和单线程几乎看不出差别，可是由于计算机的迅速发展，现在的电脑几乎都是多核CPU了，最少也是两个核心数的，这时差别就出来了：通过之前的案例我们已经知道，即使在多核CPU中，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核CPU的优势，反而由于每个线程在多个CPU上是交替执行的，导致在不同CPU上切换时造成资源的浪费，反而会更慢。即原因是一个进程只存在一把gil锁，当在执行多个线程时，内部会争抢gil锁，这会造成当某一个线程没有抢到锁的时候会让cpu等待，进而不能合理利用多核cpu资源。 四.协程1.协程是什么？协程是单线程下的并发，一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。 2.注意： python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行） 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关） 操作系统控制线程的切换，用户在单线程内控制协程的切换 3.优点与缺点：优点： 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级，单线程内就可以实现并发的效果，最大限度地利用cpu。 缺点： 协程的本质是单线程下，无法利用多核，（可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程） 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程 4.总结 必须在只有一个单线程里实现并发 修改共享数据不需加锁 用户程序里自己保存多个控制流的上下文栈 一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制） 五.IO模型1.IO模型介绍IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段： 1. 等待数据准备 2. 将数据从内核拷贝到进程中 不同IO模型的区别就是在两个阶段上各有不同的情况 补充 1234567#1、输入操作：read、readv、recv、recvfrom、recvmsg共5个函数，如果会阻塞状态，则会经历wait data和copy data两个阶段，如果设置为非阻塞则在wait 不到data时抛出异常#2、输出操作：write、writev、send、sendto、sendmsg共5个函数，在发送缓冲区满了会阻塞在原地，如果设置为非阻塞，则会抛出异常#3、接收外来链接：accept，与输入操作类似#4、发起外出链接：connect，与输出操作类似 2.阻塞IO默认情况下所有的socket都是阻塞的 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。 而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了 除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。 一个简单的解决方案： 1#在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。 该方案的问题是： 1#开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。 改进方案： 123#很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。 改进后方案其实也存在着问题： 123#“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。 对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。 总之 多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。 3.非阻塞IO可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 可以看到用户进程需要一直主动询问kernel数据准备好了没有，带来的问题就是 循环调用recv()将大幅度推高CPU占用率，在低配主机下极容易出现卡机情况。 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。 4.多路复用IO有些地方也称这种IO方式为事件驱动IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 强调： 1. 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 结论: select的优势在于可以处理多个连接，不适用于单个连接 select监听fd变化的过程分析： 12#用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到； #用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。 该模型的优点： 1#相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。 该模型的缺点： 12#首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。#其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。 5.异步IO 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 然后由于不稳定等原因异步IO用的并不多。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"并发编程","slug":"python/并发编程","permalink":"http://example.com/categories/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"349. 两个数组的交集","slug":"349-两个数组的交集","date":"2020-11-02T01:17:26.000Z","updated":"2022-04-19T10:49:43.730Z","comments":true,"path":"2020/11/02/349-两个数组的交集/","link":"","permalink":"http://example.com/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]","text":"题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 思路使用集合c++中集合有基于红黑树的set还有哈希的unordered_set，使用集合可以去除重复。 将nums1放入哈希表s1中，遍历nums2，若元素在s1中，加入结果集合ans中，最后将其转化为vector。、 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; s1(nums1.begin(), nums1.end()); unordered_set&lt;int&gt; ans; for(auto num:nums2) &#123; if(s1.find(num) != s1.end()) &#123; ans.insert(num); &#125; &#125; vector&lt;int&gt; res(ans.begin(), ans.end()); return res; &#125;&#125;; 排序，双指针排序之后利用双指针，注意加入时去重复。 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int i = 0, j = 0, n1 = nums1.size(), n2 = nums2.size(); while(i &lt; n1 &amp;&amp; j &lt; n2) &#123; // 去重复 if(nums1[i]==nums2[j] &amp;&amp; (res.size()==0 || res.back() != nums1[i])) &#123; res.push_back(nums1[i]); ++i,++j; &#125; else if(nums1[i] &gt; nums2[j]) &#123; ++j; &#125; else &#123; ++i; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"哈希","slug":"LeetCode/哈希","permalink":"http://example.com/categories/LeetCode/%E5%93%88%E5%B8%8C/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"哈希","slug":"哈希","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"140. 单词拆分 II","slug":"140-单词拆分-II","date":"2020-11-01T09:47:56.000Z","updated":"2022-04-19T10:47:38.990Z","comments":true,"path":"2020/11/01/140-单词拆分-II/","link":"","permalink":"http://example.com/2020/11/01/140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II/","excerpt":"题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。 说明： 分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。","text":"题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。 说明： 分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 12345678输入:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]输出:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] 示例 2： 12345678910输入:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]输出:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]解释: 注意你可以重复使用字典中的单词。 示例 3： 12345输入:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出:[] 思路判断是否可分用动态规划，求具体解使用回溯。 与139. 单词拆分思想类似，139题可以使用动态规划的方法，或记忆化搜索。但是此题由于样例特殊，可能出现前半段很多解，后半段无解的情况，例如下面的测试用例会导致运行超时。 12s = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;wordDict = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;,&quot;aaaaa&quot;,&quot;aaaaaa&quot;,&quot;aaaaaaa&quot;,&quot;aaaaaaaa&quot;,&quot;aaaaaaaaa&quot;,&quot;aaaaaaaaaa&quot;] 记忆化搜索 vs. 动态规划 暴力搜索会产生很多重复的子问题，记忆化搜索记录搜索结果，再次进入相同的子问题直接返回结果（用空间去换时间，与动态规划类似）。 记忆化搜索是自顶向下求解，动态规划是自底向上。本题中使用自顶向下的方法将不可拆分的情况自动剪枝，效率优于自底向上的动态规划。 代码 为了加快判断字符串是否在单词列表中，使用哈希方法unordered_set加快查找。 ans[i]保存以i为开始下标的字符串s构成的单词拆分结果。 seen[i]表示以i为开始下标的字符串s是否被搜索 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; vector&lt;int&gt; seen; vector&lt;vector&lt;string&gt;&gt; ans; unordered_set&lt;string&gt; _set; int n;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; n = s.size(); seen = vector&lt;int&gt;(n + 1); ans = vector&lt;vector&lt;string&gt;&gt;(n + 1, vector&lt;string&gt;()); // 哈希set，快速查找 _set = unordered_set(wordDict.begin(), wordDict.end()); backtrack(s, 0); return ans[0]; &#125; void backtrack(const string&amp; s, int index) &#123; if(index &gt;= n || seen[index]) return; seen[index] = 1; // substr(index, length)切割的单词区间为[index, index+length) // 要取等号，因为i=n时，全部匹配。 for(int i = index + 1;i &lt;= n;i++) &#123; auto st = s.substr(index, i - index); // 找到了 if(_set.find(st) != _set.end()) &#123; if(i == n) &#123; ans[index].push_back(st); &#125; else &#123; backtrack(s, i); if(ans[i].size() != 0) &#123; for(auto sit:ans[i]) &#123; ans[index].push_back(st+&quot; &quot;+sit); &#125; &#125; &#125; &#125; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"记忆化搜索","slug":"LeetCode/记忆化搜索","permalink":"http://example.com/categories/LeetCode/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"463. 岛屿的周长","slug":"463-岛屿的周长","date":"2020-10-30T01:28:04.000Z","updated":"2022-04-19T10:50:22.110Z","comments":true,"path":"2020/10/30/463-岛屿的周长/","link":"","permalink":"http://example.com/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/","excerpt":"题目描述给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。","text":"题目描述给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 12345678输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]输出: 16解释: 它的周长是下面图片中的 16 个黄色的边： 思路 迭代法，判断每个格子四周的状态。 lambda表达式 1[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125; 可以看到，Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-&gt; 返回值类型、{函数体}. 详细可以看这篇博客 C++之Lambda表达式 C++代码12345678910111213141516171819202122class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int r = grid.size(), c = grid[0].size(); auto check = [&amp;](int x, int y) -&gt; int &#123; if(grid[x][y]==0) return 0; int res = 4; if(x &gt; 0 &amp;&amp; grid[x - 1][y]==1) --res; if(x &lt; r - 1 &amp;&amp; grid[x + 1][y]==1) --res; if(y &gt; 0 &amp;&amp; grid[x][y - 1]==1) --res; if(y &lt; c - 1 &amp;&amp; grid[x][y + 1]==1) --res; return res; &#125;; int ans = 0; for(int i = 0;i &lt; r;++i) &#123; for(int j = 0;j &lt; c;++j) &#123; ans += check(i, j); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"迭代","slug":"迭代","permalink":"http://example.com/tags/%E8%BF%AD%E4%BB%A3/"}]},{"title":"142. 环形链表 II","slug":"142-环形链表-II","date":"2020-10-29T14:33:18.000Z","updated":"2022-04-19T10:56:17.960Z","comments":true,"path":"2020/10/29/142-环形链表-II/","link":"","permalink":"http://example.com/2020/10/29/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/","excerpt":"题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？","text":"题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 说明：不允许修改给定的链表。 进阶： 你是否可以使用 O(1) 空间解决此题？ 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 解题思路使用快慢指针，快指针每次走2步，慢指针每次走1步。1. 如果有环必定会相遇。证明： 设快指针速度$v{fast}=2$，慢指针速度$v{slow}=1$，行走时间为$t$，两者的距离差为$d$，环的周长为$L$，环之前的路径长度为$S$。 易见$d=(v{fast}-v{slow})*t=t$，因为$t$的值是连续递增整数，若有环，则必定存在某一时刻$t=L$，即必定相遇。 2. 相遇时刻慢指针的位置相对于入口走了$L-S$证明： 慢指针在走$S$到达环入口时，由于快指针速度是慢指针的两倍，因此快指针此时已在环中走了$S$。此时两者都在环中，开始进行追逐，设当前时刻$t=0$。 因为都在环中，快指针追慢指针，可以认为快指针落后慢指针$L-S$，因此相遇时需要满足$(v{fast}-v{slow})*t=L-S$，即$t=L-S$时相遇，又因为慢指针速度为$1$，因此相遇时慢指针相对于环入口走了$L-S$。 3. 相遇后慢指针再走$S$即到达环入口 可以再使用指针t从head开始行进，t和慢指针同步走$S$，两者相遇，相遇位置为环入口。 C++代码1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==nullptr) return head; ListNode *fast, *slow, *t; fast = slow = t = head; do &#123; fast = fast-&gt;next; if(fast &amp;&amp; fast-&gt;next) fast = fast-&gt;next; else return nullptr; slow = slow-&gt;next; &#125;while(slow != fast); while(t!=slow) &#123; t = t-&gt;next; slow = slow-&gt;next; &#125; return t; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"链表","slug":"LeetCode/链表","permalink":"http://example.com/categories/LeetCode/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"1529. 灯泡开关 IV","slug":"1529-灯泡开关-IV","date":"2020-10-29T14:09:39.000Z","updated":"2022-04-19T10:53:15.600Z","comments":true,"path":"2020/10/29/1529-灯泡开关-IV/","link":"","permalink":"http://example.com/2020/10/29/1529-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-IV/","excerpt":"题目描述房间中有 n 个灯泡，编号从 0 到 n-1 ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。 请你设法使得灯泡的开关状态和 target 描述的状态一致，其中 target[i] 等于 1 第 i 个灯泡是开着的，等于 0 意味着第 i 个灯是关着的。 有一个开关可以用于翻转灯泡的状态，翻转操作定义如下： 选择当前配置下的任意一个灯泡（下标为 i ） 翻转下标从 i 到 n-1 的每个灯泡 翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。 返回达成 target 描述的状态所需的 最少 翻转次数。","text":"题目描述房间中有 n 个灯泡，编号从 0 到 n-1 ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。 请你设法使得灯泡的开关状态和 target 描述的状态一致，其中 target[i] 等于 1 第 i 个灯泡是开着的，等于 0 意味着第 i 个灯是关着的。 有一个开关可以用于翻转灯泡的状态，翻转操作定义如下： 选择当前配置下的任意一个灯泡（下标为 i ） 翻转下标从 i 到 n-1 的每个灯泡 翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。 返回达成 target 描述的状态所需的 最少 翻转次数。 示例 1： 1234567输入：target = &quot;10111&quot;输出：3解释：初始配置 &quot;00000&quot;.从第 3 个灯泡（下标为 2）开始翻转 &quot;00000&quot; -&gt; &quot;00111&quot;从第 1 个灯泡（下标为 0）开始翻转 &quot;00111&quot; -&gt; &quot;11000&quot;从第 2 个灯泡（下标为 1）开始翻转 &quot;11000&quot; -&gt; &quot;10111&quot;至少需要翻转 3 次才能达成 target 描述的状态 示例 2： 123输入：target = &quot;101&quot;输出：3解释：&quot;000&quot; -&gt; &quot;111&quot; -&gt; &quot;100&quot; -&gt; &quot;101&quot;. 示例 3： 12输入：target = &quot;00000&quot;输出：0 示例 4： 12输入：target = &quot;001011101&quot;输出：5 提示： 1 &lt;= target.length &lt;= 10^5 target[i] == &#39;0&#39; 或者 target[i] == &#39;1&#39; 思路动态规划 $dp[i][0]$表示从第i个灯泡到末尾转换为和目标状态相同的需要的次数，$0\\leq i &lt; n$ $dp[i][1]$表示从第i个灯泡到末尾转换为和目标状态相反的需要的次数，$0\\leq i &lt; n$状态转移方程 dp[i][0] = \\begin {cases} dp[i+1][0],&\\text{target[i]='0'} \\\\ dp[i+1][1]+1,&\\text{target[i]='1'} \\end{cases} dp[i][1] = \\begin {cases} dp[i+1][0]+1,&\\text{target[i]='0'} \\\\ dp[i+1][1],&\\text{target[i]='1'} \\end{cases} dp[n][0] = dp[n][1] = 0 Python代码123456789101112class Solution: def minFlips(self, target: str) -&gt; int: dp = [[0]*2 for _ in range(len(target)+1)] for i in range(len(target)-1,-1,-1): # print(i,end = &#x27;,&#x27;) if target[i] == &#x27;0&#x27;: dp[i][0] = dp[i+1][0] dp[i][1] = dp[i+1][0] + 1 else: dp[i][0] = dp[i+1][1] + 1 dp[i][1] = dp[i+1][1] return dp[0][0]","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"}]},{"title":"LCP 25. 古董键盘","slug":"LCP-25-古董键盘","date":"2020-10-29T08:20:19.000Z","updated":"2022-04-19T12:04:27.730Z","comments":true,"path":"2020/10/29/LCP-25-古董键盘/","link":"","permalink":"http://example.com/2020/10/29/LCP-25-%E5%8F%A4%E8%91%A3%E9%94%AE%E7%9B%98/","excerpt":"题目描述小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 a~z 可以按下，且每个字母最多仅能被按 k 次。 小扣随机按了 n 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。","text":"题目描述小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 a~z 可以按下，且每个字母最多仅能被按 k 次。 小扣随机按了 n 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。 示例 1： 输入：k = 1, n = 1 输出：26 解释：由于只能按一次按键，所有可能的字符串为 “a”, “b”, … “z” 示例 2： 输入：k = 1, n = 2 输出：650 解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 “ab”, “ac”, … “zy” 提示： 1 &lt;= k &lt;= 5 1 &lt;= n &lt;= 26*k 思路动态规划$dp[i][j]$表示总长度为$i$，用了前$j$种字母可能出现的字符串的数量，可以得到如下转移方程。 dp[i][j]=\\sum_{x=0}^kdp[i-x][j-1]·C_i^x其中，$x$表示第$j$种字母出现的次数，其值可以为$0,1,..k$，对于每一个$x$，都有$C_i^x$种位置可以选择。例如，$x=2$，表示第$j$种字符出现了$2$次，他可能出现在前$i$个位置中的任意两个，是一个组合问题，其结果是$C_i^2$。 C++代码123456789101112131415161718192021222324252627class Solution &#123;public: int keyboard(int k, int n) &#123; vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(27, 0L)); for(int i = 0;i &lt;= 26;i++) dp[0][i] = 1; for(int i = 1;i&lt;=n;i++) &#123; for(int j = 1;j &lt;= 26;j++) &#123; for(int x = 0;x &lt;= k;x++) &#123; if(i-x &gt;= 0) dp[i][j] += dp[i-x][j-1]*C(i,x); &#125; dp[i][j] %= 1000000007; &#125; &#125; return dp[n][26]; &#125; long long C(int m, int n) &#123; int k = 1; long long ans=1; while(k &lt;= n) &#123; ans=((m-k+1)*ans)/k; k++; &#125; return ans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"STL","slug":"C/STL","permalink":"http://example.com/categories/C/STL/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"单调栈","slug":"LeetCode/单调栈","permalink":"http://example.com/categories/LeetCode/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"哈希","slug":"LeetCode/哈希","permalink":"http://example.com/categories/LeetCode/%E5%93%88%E5%B8%8C/"},{"name":"链表","slug":"LeetCode/链表","permalink":"http://example.com/categories/LeetCode/%E9%93%BE%E8%A1%A8/"},{"name":"模拟","slug":"LeetCode/模拟","permalink":"http://example.com/categories/LeetCode/%E6%A8%A1%E6%8B%9F/"},{"name":"动态规划","slug":"LeetCode/动态规划","permalink":"http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"堆","slug":"LeetCode/堆","permalink":"http://example.com/categories/LeetCode/%E5%A0%86/"},{"name":"归并排序","slug":"LeetCode/归并排序","permalink":"http://example.com/categories/LeetCode/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"LeetCode/贪心","permalink":"http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"},{"name":"位运算","slug":"LeetCode/位运算","permalink":"http://example.com/categories/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"广度优先搜索","slug":"LeetCode/广度优先搜索","permalink":"http://example.com/categories/LeetCode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"},{"name":"并发编程","slug":"python/并发编程","permalink":"http://example.com/categories/python/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"记忆化搜索","slug":"LeetCode/记忆化搜索","permalink":"http://example.com/categories/LeetCode/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"每日一题","slug":"每日一题","permalink":"http://example.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"哈希","slug":"哈希","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"单调栈","slug":"单调栈","permalink":"http://example.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"BFS","slug":"BFS","permalink":"http://example.com/tags/BFS/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"区间","slug":"区间","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"转载","slug":"转载","permalink":"http://example.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"并发编程","slug":"并发编程","permalink":"http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"迭代","slug":"迭代","permalink":"http://example.com/tags/%E8%BF%AD%E4%BB%A3/"}]}