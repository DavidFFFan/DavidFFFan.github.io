<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>402. 移掉K位数字</title>
    <link href="/2020/11/15/402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2020/11/15/402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/">题目描述</a></h2><p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p><p><strong>注意:</strong></p><ul><li><p><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></p></li><li><p><em>num</em> 不会包含任何前导零。</p></li></ul><span id="more"></span><p><strong>示例 1 :</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs dart">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;1432219&quot;</span>, k = <span class="hljs-number">3</span><br>输出: <span class="hljs-string">&quot;1219&quot;</span><br>解释: 移除掉三个数字 <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, 和 <span class="hljs-number">2</span> 形成一个新的最小的数字 <span class="hljs-number">1219</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;10200&quot;</span>, k = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">&quot;200&quot;</span><br>解释: 移掉首位的 <span class="hljs-number">1</span> 剩下的数字为 <span class="hljs-number">200.</span> 注意输出不能有任何前导零。<br></code></pre></td></tr></table></figure><p>示例 <strong>3 :</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入: <span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;10&quot;</span>, k = <span class="hljs-number">2</span><br>输出: <span class="hljs-string">&quot;0&quot;</span><br>解释: 从原数字移除所有的数字，剩余为空就是<span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>删掉前<code>k</code>个字符中的最大字符，删<code>k</code>次。</p><p>错误样例<code>123</code>， <code>k = 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeKdigits</span><span class="hljs-params">(string num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">auto</span> cmp = [](pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; x, pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; y) &#123;<br>            <span class="hljs-keyword">return</span> x.first &lt; y.first;<br>        &#125;;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n || cnt &lt; k) &#123;<br>            <span class="hljs-keyword">if</span>(i &lt; k) &#123;<br>                q.<span class="hljs-built_in">emplace</span>(num[i], i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt &lt; k) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                visit[t.second] = <span class="hljs-number">1</span>;<br>                ++cnt;<br>                <span class="hljs-keyword">if</span>(i &lt; n)<br>                q.<span class="hljs-built_in">emplace</span>(num[i], i);<br>            &#125;<br>            ++i;<br>        &#125;<br>        <br>        string res;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-keyword">if</span>(!visit[i]) &#123;<br>                <span class="hljs-keyword">if</span>(!flag &amp;&amp; num[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag)<br>                    res.<span class="hljs-built_in">push_back</span>(num[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>?res:<span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="贪心-1"><a href="#贪心-1" class="headerlink" title="贪心"></a>贪心</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeKdigits</span><span class="hljs-params">(string num, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        vector&lt;<span class="hljs-type">char</span>&gt; s;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;<br>        s.<span class="hljs-built_in">push_back</span>(num[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">while</span>(i &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(j &lt; k &amp;&amp; !s.<span class="hljs-built_in">empty</span>() &amp;&amp; num[i] &lt; s.<span class="hljs-built_in">back</span>()) &#123;<br>                s.<span class="hljs-built_in">pop_back</span>();<br>                ++j;<br>            &#125;<br>            s.<span class="hljs-built_in">push_back</span>(num[i]);<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt; k) &#123;<br>            s.<span class="hljs-built_in">pop_back</span>();<br>            j++;<br>        &#125;<br>        <br>        string res;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>();++i) &#123;<br>            <span class="hljs-keyword">if</span>(!flag &amp;&amp; s[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) res.<span class="hljs-built_in">push_back</span>(s[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>? res: <span class="hljs-string">&quot;0&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>单调栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1122. 数组的相对排序</title>
    <link href="/2020/11/14/1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/11/14/1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/">题目描述</a></h2><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p> <span id="more"></span><p><strong>示例：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs dns">输入：arr1 = [<span class="hljs-number">2,3,1,3</span>,<span class="hljs-number">2,4,6,7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">19</span>], arr2 = [<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">2,2,2,1</span>,<span class="hljs-number">4,3,3,9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>arr1.length, arr2.length &lt;= 1000</code></li><li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li><li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li><li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>将<code>arr2</code>放入<code>unordered_set</code>中，可以快速进行<code>arr1</code>的查找</li><li>统计<code>arr1</code>中在<code>arr2</code>出现的次数</li><li>没有出现的放在另外的<code>vector</code>中</li><li>最后进行 桶排序 + 快速排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">relativeSortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr2)</span> </span>&#123;<br>        <span class="hljs-comment">// 哈希表用于快速查找</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr2.begin(), arr2.end())</span></span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(arr1.size())</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:arr1) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">find</span>(num)!=s.<span class="hljs-built_in">end</span>()) &#123;<br>                ++m[num];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:arr2) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; m[num];++j) &#123;<br>                ans[i++] = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; num:temp) &#123;<br>            ans[i++] = num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>哈希</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>每日一题</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>328. 奇偶链表</title>
    <link href="/2020/11/13/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/13/328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;NULL <br>输出: <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ul><li><code>odd</code>指向奇数节点，<code>even</code>指向偶数节点。</li></ul><p><strong>交换顺序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">odd-&gt;next = even-&gt;next;<br>odd = odd-&gt;next;<br>even-&gt;next = odd-&gt;next;<br>even =even-&gt;next;<br></code></pre></td></tr></table></figure><p><strong>结束条件</strong></p><ul><li><code>odd</code>为空或<code>even</code>为空，注意循环中的越界检查</li></ul><p><strong>需要保存的变量</strong></p><ul><li><p>奇数链表的结尾和偶数链表的起点</p></li><li><p>奇数链表的结尾可能为空，使用<code>preodd</code>变量暂存</p></li><li><p>偶数链表的起点为<code>head-&gt;next</code>，使用<code>Listnode *const</code>变量<code>second</code>存储</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span> || head-&gt;next-&gt;next==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* odd = head, *even = head-&gt;next, *preodd = <span class="hljs-literal">nullptr</span>;<br>        ListNode *<span class="hljs-type">const</span> second = even;<br>        <span class="hljs-keyword">while</span>(even &amp;&amp; odd) &#123;<br>            odd-&gt;next = even-&gt;next;<br>            preodd = odd;<br>            odd = odd-&gt;next;<br>            <span class="hljs-keyword">if</span>(odd==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;<br>            even-&gt;next = odd-&gt;next;<br>            even =even-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(odd) &#123;<br>            odd-&gt;next = second;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preodd-&gt;next = second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>922. 按奇偶排序数组 II</title>
    <link href="/2020/11/12/922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/"/>
    <url>/2020/11/12/922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">题目描述</a></h2><p>给定一个非负整数数组 <code>A</code>， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p> <span id="more"></span><p><strong>示例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[4,2,5,7]</span><br>输出：<span class="hljs-selector-attr">[4,5,2,7]</span><br>解释：<span class="hljs-selector-attr">[4,7,2,5]</span>，<span class="hljs-selector-attr">[2,5,4,7]</span>，<span class="hljs-selector-attr">[2,7,4,5]</span> 也会被接受。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 20000</code></li><li><code>A.length % 2 == 0</code></li><li><code>0 &lt;= A[i] &lt;= 1000</code></li></ol><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>使用备用数组暂存，时间复杂度 $O(N)$，空间复杂度 $O(N)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArrayByParityII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp0</span><span class="hljs-params">(n/<span class="hljs-number">2</span>)</span>, <span class="hljs-title">temp1</span><span class="hljs-params">(n/<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-keyword">if</span>(A[i]&amp;<span class="hljs-number">1</span>) &#123;<br>                temp1[k++] = A[i];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp0[j++] = A[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;++i) &#123;<br>            A[<span class="hljs-number">2</span>*i] = temp0[i];<br>            A[<span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>] = temp1[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> A;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>514. 自由之路</title>
    <link href="/2020/11/11/514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/"/>
    <url>/2020/11/11/514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/freedom-trail/">题目描述</a></h2><p>视频游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 <strong>ring</strong>，表示刻在外环上的编码；给定另一个字符串 <strong>key</strong>，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p><p>最初，<strong>ring</strong> 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 <strong>key</strong> 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 <strong>key</strong> 中的所有字符。</p><p>旋转 <strong>ring</strong> 拼出 key 字符 <strong>key[i]</strong> 的阶段中：</p><ol><li><p>您可以将 <strong>ring</strong> 顺时针或逆时针旋转<strong>一个位置</strong>，计为1步。旋转的最终目的是将字符串 <strong>ring</strong> 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 <strong>key[i] 。</strong></p></li><li><p>如果字符 <strong>key[i]</strong> 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 <strong>1 步</strong>。按完之后，您可以开始拼写 <strong>key</strong> 的下一个字符（下一阶段）, 直至完成所有拼写。</p></li></ol><span id="more"></span><p><strong>示例：</strong></p><p><img src="ring.jpg" alt="img"></p><figure class="highlight processing"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs processing">输入: ring = <span class="hljs-string">&quot;godding&quot;</span>, <span class="hljs-built_in">key</span> = <span class="hljs-string">&quot;gd&quot;</span><br>输出: <span class="hljs-number">4</span><br>解释:<br> 对于 <span class="hljs-built_in">key</span> 的第一个字符 <span class="hljs-string">&#x27;g&#x27;</span>，已经在正确的位置, 我们只需要<span class="hljs-number">1</span>步来拼写这个字符。 <br> 对于 <span class="hljs-built_in">key</span> 的第二个字符 <span class="hljs-string">&#x27;d&#x27;</span>，我们需要逆时针旋转 ring <span class="hljs-string">&quot;godding&quot;</span> <span class="hljs-number">2</span>步使它变成 <span class="hljs-string">&quot;ddinggo&quot;</span>。<br> 当然, 我们还需要<span class="hljs-number">1</span>步进行拼写。<br> 因此最终的输出是 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><strong>ring</strong> 和 <strong>key</strong> 的字符串长度取值范围均为 1 至 100；</li><li>两个字符串中都只有小写字符，并且均可能存在重复字符；</li><li>字符串 <strong>key</strong> 一定可以由字符串 <strong>ring</strong> 旋转拼出。</li></ol><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>每次找最近的，方法是错误的…</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>感觉是，但是写不出来。</p><p>看了官方题解的状态转移方程，感觉也不是很难（还是自己太菜了😭）</p><p>转移方程，<code>key</code>中的第<code>i</code>个字符与<code>ring</code>中的第<code>j</code>个字符最少次数为<code>dp[i][j]</code></p><p>得到状态转移方程</p><script type="math/tex; mode=display">dp[i][j]= \min_{k∈pos[key[i−1]]}\{dp[i−1][k]+\min\{\text{abs}(j−k),n−\text{abs}(j−k)\}+1\}</script><p>其实仔细想想，这个问题的划分好像也不难，子问题比原问题问题规模小<code>1</code>，子问题通过枚举计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRotateSteps</span><span class="hljs-params">(string ring, string key)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pos</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-type">int</span> l1 = ring.<span class="hljs-built_in">size</span>(), l2 = key.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; l1;++i) &#123;<br>            pos[ring[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(l2, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(l1,INT_MAX));<br>        <span class="hljs-comment">// key中第i个字符，j为key[i]在ring中的位置，k为key[i-1]在ring中的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; l2;++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j: pos[key[i] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                <span class="hljs-type">int</span> min_val = INT_MAX;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                    min_val = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(j - i), l1 - <span class="hljs-built_in">abs</span>(j - i)) + <span class="hljs-number">1</span>, min_val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k:pos[key[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                        min_val = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(k - j) , l1 - <span class="hljs-built_in">abs</span>(k - j)) + dp[i<span class="hljs-number">-1</span>][k] + <span class="hljs-number">1</span>, min_val);<br>                    &#125;<br>                &#125;<br>                dp[i][j] = min_val;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:pos[key.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>            res = <span class="hljs-built_in">min</span>(dp.<span class="hljs-built_in">back</span>()[i], res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31. 下一个排列</title>
    <link href="/2020/11/10/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2020/11/10/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/next-permutation/">题目描述</a></h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code><em>**</em></p><span id="more"></span><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从不存在入手，如果不存在下一个更大排列，这个排列一定是一个<code>非严格降序(存在等号)</code>排列。</p><ul><li>翻转序列，即为题中要求的下一个更大序列。</li></ul><p>那么如果存在下一个更大的排列，在原始排列中一定存在一小段<code>严格升序的排列</code>。</p><ul><li>从末尾开始遍历排列，找到第一个升序位置，即<code>nums[i] &gt; nums[i-1]</code></li><li>在<code>[i+1,n)</code>的区间上找到比<code>nums[i]</code>大的元素位置<code>j</code>，<code>nums[i]</code>与<code>nums[j]</code>进行交换，这样保证前边是不变的，后边的序列会变大。</li><li><strong><code>[i+1,n)</code></strong>中的序列是降序的，将其进行翻转，使得后边的序列最小，总体的排列即下一个最大的排列。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), i = n - <span class="hljs-number">2</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> || n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>]) &#123;<br>            --i;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">while</span>(j &gt; i) &#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &gt; nums[i]) <span class="hljs-keyword">break</span>;<br>                --j;<br>            &#125;  <br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>,nums.<span class="hljs-built_in">end</span>() );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>973. 最接近原点的 K 个点</title>
    <link href="/2020/11/09/973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-K-%E4%B8%AA%E7%82%B9/"/>
    <url>/2020/11/09/973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-K-%E4%B8%AA%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">题目描述</a></h2><p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。</p><p>（这里，平面上两点之间的距离是欧几里德距离。）</p><p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,3],[-2,2]]</span>, K = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[-2,2]]</span><br>解释： <br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，<br>(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 和原点之间的距离为 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>)，<br>由于 <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">8</span>) &lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">10</span>)，(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>) 离原点更近。<br>我们只需要距离原点最近的 K = <span class="hljs-number">1</span> 个点，所以答案就是 <span class="hljs-string">[[-2,2]]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[3,3],[5,-1],[-2,4]]</span>, K = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[[3,3],[-2,4]]</span><br>（答案 <span class="hljs-string">[[-2,4],[3,3]]</span> 也会被接受。）<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code>-10000 &lt; points[i][0] &lt; 10000</code></li><li><code>-10000 &lt; points[i][1] &lt; 10000</code></li></ol><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="维护一个大小为K的大顶堆"><a href="#维护一个大小为K的大顶堆" class="headerlink" title="维护一个大小为K的大顶堆"></a>维护一个大小为K的大顶堆</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; x1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; x2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(x1) &lt; <span class="hljs-built_in">func</span>(x2); <br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; x)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>];<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kClosest</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points, <span class="hljs-type">int</span> K) &#123;<br>        priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;, cmp&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; point:points) &#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>() &lt; K) &#123;<br>                q.<span class="hljs-built_in">push</span>(point);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">func</span>(q.<span class="hljs-built_in">top</span>()) &gt; <span class="hljs-built_in">func</span>(point)) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">push</span>(point);<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p><code>priority_queue</code>的三个模板参数，使用<code>lambda</code>时，要使用<code>decltype</code>解析类型，并在构造函数中传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = std::vector&lt;T&gt;,<br>    <span class="hljs-keyword">class</span> Compare = std::less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt;<br>&gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">kClosest</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points, <span class="hljs-type">int</span> K) &#123;<br>        <span class="hljs-keyword">auto</span> func= [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; x) &#123;<br>            <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]*x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>]*x[<span class="hljs-number">1</span>];<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> cmp =[&amp;func](vector&lt;<span class="hljs-type">int</span>&gt;&amp; x1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; x2) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(x1) &lt; <span class="hljs-built_in">func</span>(x2); <br>        &#125;;<br>        priority_queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">q</span>(cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; point:points) &#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>() &lt; K) &#123;<br>                q.<span class="hljs-built_in">push</span>(point);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">func</span>(q.<span class="hljs-built_in">top</span>()) &gt; <span class="hljs-built_in">func</span>(point)) &#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">push</span>(point);<br>                &#125;<br>            &#125;<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>堆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>962. 最大宽度坡</title>
    <link href="/2020/11/08/962-%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1/"/>
    <url>/2020/11/08/962-%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/maximum-width-ramp/">题目描述</a></h2><p>给定一个整数数组 <code>A</code>，<em>坡</em>是元组 <code>(i, j)</code>，其中 <code>i &lt; j</code> 且 <code>A[i] &lt;= A[j]</code>。这样的坡的宽度为 <code>j - i</code>。</p><p>找出 <code>A</code> 中的坡的最大宽度，如果不存在，返回 0 。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-attr">[6,0,8,2,1,5]</span><br>输出：<span class="hljs-number">4</span><br>解释：<br>最大宽度的坡为 (<span class="hljs-selector-tag">i</span>, j) = (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>): A<span class="hljs-selector-attr">[1]</span> = <span class="hljs-number">0</span> 且 A<span class="hljs-selector-attr">[5]</span> = <span class="hljs-number">5</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">9,8,1,0</span>,<span class="hljs-number">1,9,4,0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">7</span><br>解释：<br>最大宽度的坡为 (i, j) = (<span class="hljs-number">2</span>, <span class="hljs-number">9</span>): <span class="hljs-keyword">A</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span> 且 <span class="hljs-keyword">A</span>[<span class="hljs-number">9</span>] = <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 50000</code></li><li><code>0 &lt;= A[i] &lt;= 50000</code></li></ol><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h5 id="单调栈-排序-双指针"><a href="#单调栈-排序-双指针" class="headerlink" title="单调栈+排序+双指针"></a>单调栈+排序+双指针</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxWidthRamp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = A.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(&#123;A[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-keyword">if</span>(A[i] &lt; s.<span class="hljs-built_in">top</span>().first) &#123;<br>                s.<span class="hljs-built_in">push</span>(&#123;A[i], i&#125;);<br>            &#125;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n);<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            arr[i] = &#123;A[i], i&#125;;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), [](pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; x1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; x2) &#123;<br>            <span class="hljs-keyword">return</span> x1.first &lt; x2.first || (x1.first==x2.first &amp;&amp; x1.second &gt; x2.second);<br>        &#125;);<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> t = INT_MAX / <span class="hljs-number">2</span>;;<br>        <span class="hljs-keyword">while</span>(i &lt; n) &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[i].first &gt;= s.<span class="hljs-built_in">top</span>().first ) &#123;<br>                t = s.<span class="hljs-built_in">top</span>().second;<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, arr[i].second - t);<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>单调栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>327. 区间和的个数</title>
    <link href="/2020/11/08/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2020/11/08/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/count-of-range-sum/">题目描述</a></h2><p>给定一个整数数组 <code>nums</code>，返回区间和在 <code>[lower, upper]</code> 之间的个数，包含 <code>lower</code> 和 <code>upper</code>。<br>区间和 <code>S(i, j)</code> 表示在 <code>nums</code> 中，位置从 <code>i</code> 到 <code>j</code> 的元素之和，包含 <code>i</code> 和 <code>j</code> (<code>i</code> ≤ <code>j</code>)。</p><p><strong>说明:</strong><br>最直观的算法复杂度是 <em>O</em>(<em>n</em>2) ，请在此基础上优化你的算法。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs subunit">输入: nums = [<span class="hljs-string">-2</span>,5,<span class="hljs-string">-1</span>], lower = <span class="hljs-string">-2</span>, upper = 2,<br>输出: 3 <br>解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: <span class="hljs-string">-2</span>, <span class="hljs-string">-1</span>, 2。<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>计算全部区间，$O(n^2)$，超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> rangesum = <span class="hljs-number">0L</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; n;++j) &#123;<br>                rangesum += nums[j];<br>                <span class="hljs-keyword">if</span>(rangesum &gt;= lower &amp;&amp; rangesum &lt;= upper) ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h5 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h5><p>计算前缀和<code>presum</code>，问题转化为对任意的前缀和<code>val = presum[i] - presum[j](i &gt;= j)</code>落在 <code>[lower, upper]</code> 之间的个数。</p><p>计算前缀和注意第一个元素要补0。</p><p>若前缀和无序，计算的时间复杂度依旧是$O(n^2)$，若前缀和有序。计算时，可以使用双指针。</p><h5 id="问题划分"><a href="#问题划分" class="headerlink" title="问题划分"></a>问题划分</h5><p>若两个区间<code>[l,m)</code>，<code>[m, r)</code>的前缀和都是有序的，可以利用三指针。</p><ul><li><p><code>p0</code>指向<code>l</code>， <code>p1</code>指向<code>m</code>，<code>p2</code>指向<code>m</code></p></li><li><p><code>p1</code>后移直到<code>presum[p1] - presum[p0] &gt;= lower</code></p></li><li><p><code>p2</code>后移直到<code>presum[p2] - presum[p0] &gt; upper</code></p></li><li><p><code>p2 - p1</code>则为以<code>p0</code>为起点的区间数量，由于<code>[l, m)</code>是有序的，因此<code>p0</code>后移之后，<code>p1</code>，<code>p2</code>必定后移，不用向前回溯，减少了时间。</p></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merage</span><span class="hljs-params">(vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&amp; presum, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-comment">// 左右右开，[l,r)，区间长度为1时，直接返回0</span><br>        <span class="hljs-keyword">if</span>(l == r - <span class="hljs-number">1</span> || l == r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = l + (r - l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        res += <span class="hljs-built_in">merage</span>(presum, l, m, lower, upper);<br>        res += <span class="hljs-built_in">merage</span>(presum, m, r, lower, upper);<br>        <span class="hljs-type">int</span> p0 = l, p1 = m, p2 = m;<br>        <span class="hljs-keyword">while</span>(p0 &lt; m) &#123;<br>            <span class="hljs-keyword">while</span>(p1 &lt; r &amp;&amp; presum[p1] - presum[p0] &lt; lower) ++p1;<br>            <span class="hljs-keyword">while</span>(p2 &lt; r &amp;&amp; presum[p2] - presum[p0] &lt;= upper) ++p2;<br>            res += p2 - p1;<br>            ++p0;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(r - l)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = l, k = m;i &lt; r - l;++i) &#123;<br>            <span class="hljs-keyword">if</span>(j &lt; m &amp;&amp; k &lt; r) &#123;<br>                <span class="hljs-keyword">if</span>(presum[j] &lt; presum[k]) <br>                temp[i] = presum[j++];<br>                <span class="hljs-keyword">else</span> <br>                temp[i] = presum[k++];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; m)&#123;<br>                temp[i] = presum[j++];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                temp[i] = presum[k++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; r - l;++i) &#123;<br>            presum[i + l] = temp[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> lower, <span class="hljs-type">int</span> upper)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++i) &#123;<br>            presum[i+<span class="hljs-number">1</span>] = presum[i] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merage</span>(presum, <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, lower, upper);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>$T(N) = 2*T(N/2) + O(N)$</p><p>$T(N) = O(NlogN)$</p><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>设空间占用为 $M(N)$，递归调用所需空间为 $M(N/2)$，而合并数组所需空间为 O(N)O(N)，故</p><script type="math/tex; mode=display">M(N) = \max\big\{M(N/2), O(N)\big\} = M(N/2) + O(N)</script><p>$M(N) = O(N)$</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>归并排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <link href="/2020/11/08/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <url>/2020/11/08/122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">题目描述</a></h2><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p> <span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></p></li><li><p><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></p></li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>相邻两天，如果第二天比第一天价格高就第一天买入，第二天卖出。</p><p>贪心算法只能用于计算最大利润，<strong>计算的过程并不是实际的交易过程</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-keyword">if</span>(prices[i - <span class="hljs-number">1</span>] &lt; prices[i]) &#123;<br>                res += prices[i] - prices[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>由于不能同时参与多笔交易，因此最多持有1只股票，每天都只有两种状态，持有和不持有。</p><p>定义$dp[i][0]$为前$i$天交易完成且第$i$天不持有的最大收益，$dp[i][0]$为前$i$天交易完成且第$i$天持有的最大收益。</p><h5 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h5><p>第$i$天不持有股票的最大收益可能和前一天不持有相同，也可能来自前一天持有，第$i$天卖出，因此可以写出如下转移方程。</p><script type="math/tex; mode=display">dp[i][0] = max\{dp[i-1][0], dp[i-1][1] + prices[i]\}</script><p>同理</p><script type="math/tex; mode=display">dp[i][1] = max\{dp[i-1][1], dp[i-1][0] - prices[i]\}</script><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>转移方程只有相邻两项有关系，因此可以优化空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hold = -prices[<span class="hljs-number">0</span>], nhold = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n;++i) &#123;<br>            <span class="hljs-keyword">auto</span> t = hold;<br>            hold = <span class="hljs-built_in">max</span>(hold, nhold - prices[i]);<br>            nhold = <span class="hljs-built_in">max</span>(nhold, t + prices[i]);<br>        &#125;  <br>        <span class="hljs-keyword">return</span> nhold;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>贪心</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1356. 根据数字二进制下 1 的数目排序</title>
    <link href="/2020/11/06/1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B-1-%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/11/06/1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B-1-%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">题目描述</a></h2><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p><p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">输入：arr = [0,1,2,3,4,5,6,7,8]<br>输出：[0,1,2,4,8,3,5,6,7]<br>解释：[0] 是唯一一个有<span class="hljs-number"> 0 </span>个<span class="hljs-number"> 1 </span>的数。<br>[1,2,4,8] 都有<span class="hljs-number"> 1 </span>个<span class="hljs-number"> 1 </span>。<br>[3,5,6] 有<span class="hljs-number"> 2 </span>个<span class="hljs-number"> 1 </span>。<br>[7] 有<span class="hljs-number"> 3 </span>个<span class="hljs-number"> 1 </span>。<br>按照<span class="hljs-number"> 1 </span>的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">1024,512</span>,<span class="hljs-number">256,128,64</span>,<span class="hljs-number">32,16,8,4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1,2,4,8</span>,<span class="hljs-number">16,32,64,128</span>,<span class="hljs-number">256,512</span>,<span class="hljs-number">1024</span>]<br>解释：数组中所有整数二进制下都只有 <span class="hljs-number">1</span> 个 <span class="hljs-number">1</span> ，所以你需要按照数值大小将它们排序。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[10000,10000]</span><br>输出：<span class="hljs-string">[10000,10000]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">2,3,5,7</span>,<span class="hljs-number">11,13,17,19</span>]<br>输出：[<span class="hljs-number">2,3,5,17</span>,<span class="hljs-number">7,11,13,19</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[10,100,1000,10000]</span><br>输出：<span class="hljs-string">[10,100,10000,1000]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>统计二进制中1的个数</p><ul><li>可以判断末尾是否为1，然后进行向右移位，移位之后数字为0时则没有1。</li></ul><h6 id="使用仿函数"><a href="#使用仿函数" class="headerlink" title="使用仿函数"></a>使用仿函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">countbit</span>(x) &lt; <span class="hljs-built_in">countbit</span>(y) || (<span class="hljs-built_in">countbit</span>(x) == <span class="hljs-built_in">countbit</span>(y)&amp;&amp;x &lt; y);<br>        &#125;;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(x) &#123;<br>                cnt += x &amp; <span class="hljs-number">1</span>;<br>                x = x&gt;&gt;<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortByBits</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">cmp</span>());<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortByBits</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> countbit = [](<span class="hljs-type">int</span> x) -&gt;<span class="hljs-type">int</span> &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(x) &#123;<br>                cnt += x &amp; <span class="hljs-number">1</span>;<br>                x = x&gt;&gt;<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> cmp = [&amp;countbit](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)-&gt;<span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">countbit</span>(x) &lt; <span class="hljs-built_in">countbit</span>(y) || (<span class="hljs-built_in">countbit</span>(x) == <span class="hljs-built_in">countbit</span>(y)&amp;&amp; x &lt; y);<br>        &#125;;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h6 id="二进制常见操作"><a href="#二进制常见操作" class="headerlink" title="二进制常见操作"></a>二进制常见操作</h6><p><a href="http://graphics.stanford.edu/~seander/bithacks.html">二进制算法宝典</a></p><p>将二进制中最后的一个<code>1</code>变为<code>0</code>：<code>x &amp; x-1</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>127. 单词接龙</title>
    <link href="/2020/11/05/127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2020/11/05/127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/word-ladder/">题目描述</a></h2><p>难度中等501收藏分享切换为英文接收动态反馈</p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li><p>每次转换只能改变一个字母。</p></li><li><p>转换过程中的中间单词必须是字典中的单词。</p></li></ol><span id="more"></span><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">输入:<br>beginWord = <span class="hljs-string">&quot;hit&quot;</span>,<br>endWord = <span class="hljs-string">&quot;cog&quot;</span>,<br>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br><br>输出: <span class="hljs-number">5</span><br><br>解释: 一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>,<br>     返回它的长度 <span class="hljs-number">5</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入:<br><span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span><br><span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span><br>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br><br>输出: <span class="hljs-number">0</span><br><br>解释: <span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<span class="hljs-number">127</span>. 单词接龙<br>给定两个单词（<span class="hljs-keyword">begin</span>Word 和 <span class="hljs-keyword">end</span>Word）和一个字典，找到从 <span class="hljs-keyword">begin</span>Word 到 <span class="hljs-keyword">end</span>Word 的最短转换序列的长度。转换需遵循如下规则：<br><br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。<br>说明:<br><br>如果不存在这样的转换序列，返回 <span class="hljs-number">0</span>。<br>所有单词具有相同的长度。<br>所有单词只由小写字母组成。<br>字典中不存在重复的单词。<br>你可以假设 <span class="hljs-keyword">begin</span>Word 和 <span class="hljs-keyword">end</span>Word 是非空的，且二者不相同。<br>示例 <span class="hljs-number">1</span>:<br><br>输入:<br><span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>,<br><span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>,<br>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]<br><br>输出: <span class="hljs-number">5</span><br><br>解释: 一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>,<br>     返回它的长度 <span class="hljs-number">5</span>。<br>示例 <span class="hljs-number">2</span>:<br><br>输入:<br><span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span><br><span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span><br>wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]<br><br>输出: <span class="hljs-number">0</span><br><br>解释: <span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。<br></code></pre></td></tr></table></figure><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>最少次数，可以用<code>bfs</code>搜索.<ul><li>使用<code>queue</code>进行<code>bfs</code>搜索，每次对元素的每个位置的单词进行替换</li><li>为了快速查找使用<code>unordered_set</code>记录字典中的元素</li><li>避免相同节点重复访问，加入访问<code>unordered_set</code>类型的标记<code>vis</code></li><li>当队列为空，且没有找到时，则不存在这样的路径</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(wordList.begin(), wordList.end())</span></span>;<br>        unordered_set&lt;string&gt; vis;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">find</span>(endWord) == s.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(beginWord);<br>        vis.<span class="hljs-built_in">insert</span>(beginWord);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ++res;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; t.<span class="hljs-built_in">size</span>();++j) &#123;<br>                    <span class="hljs-keyword">auto</span> c = t[j];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">26</span>;++k) &#123;<br>                        t[j] = <span class="hljs-string">&#x27;a&#x27;</span> + k;<br>                        <span class="hljs-keyword">if</span>(t==endWord) <span class="hljs-keyword">return</span> res;<br>                        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">find</span>(t) != s.<span class="hljs-built_in">end</span>() &amp;&amp; vis.<span class="hljs-built_in">find</span>(t)==vis.<span class="hljs-built_in">end</span>()) &#123;<br>                            q.<span class="hljs-built_in">push</span>(t);<br>                            vis.<span class="hljs-built_in">insert</span>(t);<br>                        &#125;<br>                    &#125;<br>                    t[j] = c;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emplace_back、push_back杂谈</title>
    <link href="/2020/11/04/emplace-back%E3%80%81push-back%E6%9D%82%E8%B0%88/"/>
    <url>/2020/11/04/emplace-back%E3%80%81push-back%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h2><p>相当于是直接初始化，根据函数重载找最佳匹配的构造函数。若<code>emplace</code>的是一个完整的对象，则根据函数匹配规则，会自动调用拷贝构造函数。</p><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p>相当于是拷贝初始化（但是编译器不会进行优化），若<code>push</code>的对象不是完整的对象，则会进行类型转换，转换之后进行添加，添加时会调用拷贝构造函数。</p><p>若<code>push_back</code>有右值引用的版本，添加的对象又是一个右值，此时会调用右值版本的移动构造。速度也会很快。</p><span id="more"></span><h2 id="性能差别"><a href="#性能差别" class="headerlink" title="性能差别"></a>性能差别</h2><ul><li>当插入的都是临时对象时，性能没有差别。<ul><li>如果有移动构造函数，两者都会先调用构造函数，后调用移动构造函数，性能没有差别。</li><li>没有，两者都会先调用构造函数，后调用拷贝构造函数，性能没有差别。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">President</span><br>&#123;<br>    std::string name;<br>    std::string country;<br>    <span class="hljs-type">int</span> year;<br> <br>    <span class="hljs-built_in">President</span>(std::string p_name, std::string p_country, <span class="hljs-type">int</span> p_year)<br>        : <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(p_name)), <span class="hljs-built_in">country</span>(std::<span class="hljs-built_in">move</span>(p_country)), <span class="hljs-built_in">year</span>(p_year)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I am being constructed.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">President</span>(President&amp;&amp; other)<br>        : <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">country</span>(std::<span class="hljs-built_in">move</span>(other.country)), <span class="hljs-built_in">year</span>(other.year)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I am being moved.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">President</span>(<span class="hljs-type">const</span> President&amp; other)<br>        : <span class="hljs-built_in">name</span>(other.name), <span class="hljs-built_in">country</span>(other.country), <span class="hljs-built_in">year</span>(other.year)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I am copy construced.\n&quot;</span>;<br>    &#125;<br>    President&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> President&amp; other) = <span class="hljs-keyword">default</span>;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;President&gt; elections;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:\n&quot;</span>;<br>    elections.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">President</span>(<span class="hljs-string">&quot;Nelson Mandela&quot;</span>, <span class="hljs-string">&quot;South Africa&quot;</span>, <span class="hljs-number">1994</span>));<br> <br>    std::vector&lt;President&gt; reElections;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\npush_back:\n&quot;</span>;<br>    reElections.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">President</span>(<span class="hljs-string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="hljs-string">&quot;the USA&quot;</span>, <span class="hljs-number">1936</span>));<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nContents:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (President <span class="hljs-type">const</span>&amp; president: elections) &#123;<br>        std::cout &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was elected president of &quot;</span><br>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (President <span class="hljs-type">const</span>&amp; president: reElections) &#123;<br>        std::cout &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was re-elected president of &quot;</span><br>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs erlang">emplace_back:<br>I am being constructed.<br>I am being moved.<br><br>push_back:<br>I am being constructed.<br>I am being moved.<br><br>Contents:<br>Nelson Mandela was elected president <span class="hljs-keyword">of</span> South Africa in <span class="hljs-number">1994</span>.<br>Franklin Delano Roosevelt was re-elected president <span class="hljs-keyword">of</span> the USA in <span class="hljs-number">1936</span>.<br></code></pre></td></tr></table></figure><ul><li><p>当插入的时完整的对象时，性能没有差距。</p><ul><li>因为<code>push_back()</code>是直接调用拷贝构造函数，<code>emplace_back</code>是按照函数匹配规则调用拷贝构造函数，两者性能相同。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;President&gt; elections;<br>    <span class="hljs-function">President <span class="hljs-title">temp</span><span class="hljs-params">(<span class="hljs-string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="hljs-string">&quot;the USA&quot;</span>, <span class="hljs-number">1936</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:\n&quot;</span>;<br>    elections.<span class="hljs-built_in">emplace_back</span>(temp);<br> <br>    std::vector&lt;President&gt; reElections;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\npush_back:\n&quot;</span>;<br>    reElections.<span class="hljs-built_in">push_back</span>(temp);<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nContents:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (President <span class="hljs-type">const</span>&amp; president: elections) &#123;<br>        std::cout &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was elected president of &quot;</span><br>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (President <span class="hljs-type">const</span>&amp; president: reElections) &#123;<br>        std::cout &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was re-elected president of &quot;</span><br>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs erlang">I am being constructed.<br>emplace_back:<br>I am being copy constructed.<br><br>push_back:<br>I am being copy constructed.<br><br>Contents:<br>Franklin Delano Roosevelt was elected president <span class="hljs-keyword">of</span> the USA in <span class="hljs-number">1936</span>.<br>Franklin Delano Roosevelt was re-elected president <span class="hljs-keyword">of</span> the USA in <span class="hljs-number">1936</span>.<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>当<code>push_back</code>一个临时对象，<code>emplace_back</code>不是对象时，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;President&gt; elections;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;emplace_back:\n&quot;</span>;<br>elections.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="hljs-string">&quot;the USA&quot;</span>, <span class="hljs-number">1936</span>);<br><br>std::vector&lt;President&gt; reElections;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\npush_back:\n&quot;</span>;<br>reElections.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">President</span>(<span class="hljs-string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="hljs-string">&quot;the USA&quot;</span>, <span class="hljs-number">1936</span>));<br></code></pre></td></tr></table></figure><ul><li><p>如果对象有移动构造函数，两者性能差距不大，<code>emplace_back</code>会快一点。</p><p><code>push_back</code>会调用一次构造函数。</p><p><code>emplace_back</code><strong>会调用一次构造函数，再调用一次移动构造函数</strong>，会慢一点。</p></li><li><p>如果对象没有移动构造函数，<code>emplace_back</code>会快很多。</p><p><code>push_back</code>会调用一次构造函数。</p><p><code>emplace_back</code><strong>会调用一次构造函数，再调用一次拷贝构造函数</strong>，性能差距比较大。</p></li></ul></li></ul><h2 id="push-back的类别的拷贝构造函数参数如果不是const会出现错误"><a href="#push-back的类别的拷贝构造函数参数如果不是const会出现错误" class="headerlink" title="push_back的类别的拷贝构造函数参数如果不是const会出现错误"></a>push_back的类别的拷贝构造函数参数如果不是const会出现错误</h2><p><code>push_back()</code>有四种形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( <span class="hljs-type">const</span> T&amp; value )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( <span class="hljs-type">const</span> T&amp; value )</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T&amp;&amp; value )</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">( T&amp;&amp; value )</span></span>;<br></code></pre></td></tr></table></figure><p>对于非右值时，把对象转换成<code>const</code>，之后会调用拷贝构造函数，当拷贝构造函数不加<code>const</code>时，会尝试把<code>const</code>对象转换为非<code>const</code>对象，引起错误。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>57. 插入区间</title>
    <link href="/2020/11/04/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/11/04/57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/insert-interval/">题目描述</a></h2><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,3],[6,9]]</span>, newInterval = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-string">[[1,5],[6,9]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：intervals = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[12,16]</span>]</span>, newInterval = <span class="hljs-comment">[4,8]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,10]</span>,<span class="hljs-comment">[12,16]</span>]</span><br>解释：这是因为新的区间 <span class="hljs-comment">[4,8]</span> 与 <span class="hljs-comment">[3,5]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[8,10]</span> 重叠。<br></code></pre></td></tr></table></figure> <span id="more"></span><p><strong>注意：</strong>输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。</p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul><li><p>判断<code>newInterval</code>是否和<code>interval</code>有重叠</p><ul><li><p>有，进行合并，之后更新的<code>newInterval</code>（不需要插入<code>interval</code>）</p></li><li><p>没有，判断<code>newInterval</code>是否可以插入</p><ul><li><p>可以，插入<code>newInterval</code>，之后插入<code>interval</code></p></li><li><p>不可以，插入<code>interval</code></p></li></ul></li></ul></li></ul><ul><li><p><strong>合并条件</strong>：区间之间存在交叉，<code>interval[1] &gt;= newInterval[0] \&amp;\&amp; interval[0] &lt;= newInterval[1]</code></p></li><li><p><img src="image-20201104093554022.png" alt="image-20201104093554022"></p></li><li><p><strong>插入条件</strong>：新区间的尾端小于<code>interval</code>的起点，但是可能会插入很多次，因此需要打标记。<code>newInterval[1] &lt; interval[0]&amp;&amp;!flag</code>。</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">insert</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="hljs-type">int</span>&gt;&amp; newInterval) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// interval和newInterval合并，不能合并就插入</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; interval:intervals) &#123;<br>            <span class="hljs-comment">// 重合</span><br>            <span class="hljs-keyword">if</span>(interval[<span class="hljs-number">1</span>] &gt;= newInterval[<span class="hljs-number">0</span>] &amp;&amp; interval[<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]) &#123;<br>                newInterval[<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(newInterval[<span class="hljs-number">0</span>], interval[<span class="hljs-number">0</span>]);<br>                newInterval[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(newInterval[<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(newInterval[<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>] &amp;&amp; !flag) &#123;<br>                <span class="hljs-comment">// 不重合, 且是第一次</span><br>                res.<span class="hljs-built_in">push_back</span>(newInterval);<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(interval);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(newInterval);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1124. 表现良好的最长时间段</title>
    <link href="/2020/11/03/1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/"/>
    <url>/2020/11/03/1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/longest-well-performing-interval/">题目描述</a></h2><p>给你一份工作时间表 <code>hours</code>，上面记录着某一位员工每天的工作小时数。</p><p>我们认为当员工一天中的工作小时数大于 <code>8</code> 小时的时候，那么这一天就是「<strong>劳累的一天</strong>」。</p><p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 <strong>大于</strong>「不劳累的天数」。</p><p>请你返回「表现良好时间段」的最大长度。</p> <span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：hours = <span class="hljs-comment">[9,9,6,0,6,6,9]</span><br>输出：3<br>解释：最长的表现良好时间段是 <span class="hljs-comment">[9,9,6]</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= hours.length &lt;= 10000</code></li><li><code>0 &lt;= hours[i] &lt;= 16</code></li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>准备工作</strong><br>   将$工作时间&gt;8小时$记为1，$&lt;8$记为$-1$，计算前缀和<code>presum</code>。</p><p><strong>暴力枚举</strong></p><ul><li>使用两根指针，<code>i</code>，<code>j</code>去枚举区间<code>(j,i)</code>，记录最大的<code>i-j</code>，可以进行适度剪枝，but仍旧超时。</li><li>时间复杂度：$O(n^2)$，空间复杂度：$O(n)$</li><li><strong>c++代码</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + (hours[i] &gt; <span class="hljs-number">8</span>? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span> );<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n;i &gt; <span class="hljs-number">0</span>;--i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i;++j) &#123;<br>                <span class="hljs-keyword">if</span>(i - j &lt;= res) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span>(presum[i] - presum[j] &gt; <span class="hljs-number">0</span>) &#123;<br>                    res = <span class="hljs-built_in">max</span>(res, i - j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="二分查找（错误）"><a href="#二分查找（错误）" class="headerlink" title="二分查找（错误）"></a>二分查找（错误）</h5><ul><li>枚举区间值，<code>l = 0</code>，<code>r = n</code></li></ul><h5 id="前缀和-单调栈-双指针"><a href="#前缀和-单调栈-双指针" class="headerlink" title="前缀和+单调栈+双指针"></a>前缀和+单调栈+双指针</h5><p>转化之后的问题与<a href="https://leetcode-cn.com/problems/maximum-width-ramp/">962. 最大宽度坡</a>类似，使用单调栈。</p><p><strong>双指针也不一定要有序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestWPI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hours)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = hours.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;++i) &#123;<br>            presum[i + <span class="hljs-number">1</span>] = presum[i] + (hours[i] &gt; <span class="hljs-number">8</span>?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>);<br>        &#125;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;++i) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>() || presum[s.<span class="hljs-built_in">top</span>()] &gt; presum[i]) &#123;<br>                s.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> i = n;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; presum[i] &gt; presum[s.<span class="hljs-built_in">top</span>()]) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, i - s.<span class="hljs-built_in">top</span>());<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            --i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>单调栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>前缀和</tag>
      
      <tag>单调栈</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>941. 有效的山脉数组</title>
    <link href="/2020/11/03/941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/"/>
    <url>/2020/11/03/941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/valid-mountain-array/">题目描述</a></h2><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>A.length &gt;= 3</code></p></li><li><p>在 </p><figure class="highlight basic"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt; i &lt; A.length - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 条件下，存在 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><p> 使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><span id="more"></span></li></ul><p><img src="hint_valid_mountain_array.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="模拟，双指针"><a href="#模拟，双指针" class="headerlink" title="模拟，双指针"></a>模拟，双指针</h3><p>两根指针从两端找山峰的山顶，找到后判断是否为同一座山峰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, n = A.<span class="hljs-built_in">size</span>(), j = n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; n) &#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; A[i - <span class="hljs-number">1</span>]) &#123;<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                --i; <span class="hljs-comment">// 需要--，才是山顶</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(A[j] &gt; A[j + <span class="hljs-number">1</span>]) &#123;<br>                --j;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++j; <span class="hljs-comment">// 需要++，才是山顶</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==j;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python之并发编程（概念篇）</title>
    <link href="/2020/11/02/python%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%E7%AF%87%EF%BC%89/"/>
    <url>/2020/11/02/python%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E6%A6%82%E5%BF%B5%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>转载自<a href="https://www.cnblogs.com/jiangfan95/p/11436943.html">python之并发编程（概念篇）</a></p><h1 id="一-进程"><a href="#一-进程" class="headerlink" title="一.进程　　"></a>一.进程　　</h1><h3 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h3><p>进程是正在进行的一个过程或者一个任务。而负责执行任务的则是cpu。</p><span id="more"></span><h3 id="2-进程与程序的区别"><a href="#2-进程与程序的区别" class="headerlink" title="2.进程与程序的区别"></a>2.进程与程序的区别</h3><p>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。同一个程序执行两次是两个进程。</p><p>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p><h3 id="3-并发与并行"><a href="#3-并发与并行" class="headerlink" title="3.并发与并行"></a>3.并发与并行</h3><p>无论是并行还是并发，在用户看来都是’同时’运行的，而一个cpu同一时刻只能执行一个任务。</p><ol><li>并发：是伪并行，即某个时段看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）</li><li>并行：同时运行，只有具备多个cpu才能实现并行。</li></ol><p>单核下，可以利用多道技术，多核中的每个核也都可以利用多道技术（<strong>多道技术是针对单核而言的</strong>）</p><p>有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，</p><p>一旦任务1遇到I/O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术</p><p>而一旦任务1的I/O结束了，操作系统会重新调用它(<strong>需知进程的调度、分配给哪个cpu运行，由操作系统说了算</strong>)，可能被分配给四个cpu中的任意一个去执行。</p><h3 id="4-同步-异步and阻塞-非阻塞"><a href="#4-同步-异步and阻塞-非阻塞" class="headerlink" title="4.同步\异步and阻塞\非阻塞"></a>4.同步\异步and阻塞\非阻塞</h3><p>同步：A调用B，B处理直到获得结果，才返回给A。<br>需要调用者一直等待和确认调用结果是否返回， 然后继续往下执行。<br>异步：A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。<br>调用结果返回时， 会以消息或回调的方式通知调用者。</p><p>阻塞：A调用B，A被挂起直到B返回结果给A，A继续执行。<br>调用结果返回前，当前进程挂起不能够处理其他任务，一直等待调用结果返回。<br>非阻塞：A调用B，A不会被挂起，A可以执行其他操作。<br>调用结果返回前，当前进程不挂起， 可以去处理其他任务。</p><p>所以，同步异步说的是被调用者结果返回时通知进程的一种<strong>通知机制</strong>，阻塞非阻塞说的是<strong>调用结果返回前进程的状态</strong>，是挂起还是继续处理其他任务。</p><h1 id="二-线程"><a href="#二-线程" class="headerlink" title="二.线程"></a>二.线程</h1><h3 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1.什么是线程"></a>1.什么是线程</h3><p>线程是操作系统能够进行<strong>运算调度</strong>的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，<strong>一个进程中可以并发多个线程</strong>，每条线程并行执行不同的任务。</p><h3 id="2-线程与进程的区别"><a href="#2-线程与进程的区别" class="headerlink" title="2.线程与进程的区别"></a>2.线程与进程的区别</h3><ol><li><strong>线程共享</strong>创建它的进程的内存空间，<strong>进程</strong>的内存是<strong>独立</strong>的</li><li>线程可以直接访问其进程的数据段，进程拥有父进程的数据段副本</li><li>线程可以直接与其进程的其他线程通信，进程间通信需要通过一个中间代理来实现。</li><li>新线程很容易创建，创建新进程需要对父进程实现一次复制。</li><li>线程可以控制和操作同一进程里的其他线程，进程只能控制子进程。</li><li>对主线程的更改（取消，优先级更改等）可能会影响到进程中其他线程的行为; 对父进程的更改不会影响子进程。</li></ol><h3 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3.多线程"></a>3.多线程</h3><p>多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。</p><p>详细的讲分为4点：</p><ol><li>多线程共享一个进程的地址空间。</li><li>线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用</li><li>若多个线程都是<strong>cpu密集型</strong>的，那么<strong>并不能获得性能上的增强</strong>，但是如果存在<strong>大量的计算和大量的I/O处理</strong>，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。</li><li>在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python）</li></ol><h1 id="三-GIL全局解释器锁"><a href="#三-GIL全局解释器锁" class="headerlink" title="三.GIL全局解释器锁"></a>三.GIL全局解释器锁</h1><p>每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程在运行，目的是解决多线程同时竞争程序中的全局变量而出现的线程安全问题。它并不是python语言的特性，仅仅是由于历史的原因在CPython解释器中难以移除，因为python语言运行环境大部分默认在CPython解释器中。</p><p>由于以前的电脑基本都是单核CPU，多线程和单线程几乎看不出差别，可是由于计算机的迅速发展，现在的电脑几乎都是多核CPU了，最少也是两个核心数的，这时差别就出来了：通过之前的案例我们已经知道，即使在多核CPU中，多线程同一时刻也只有一个线程在运行，这样不仅不能利用多核CPU的优势，反而由于每个线程在多个CPU上是交替执行的，导致在不同CPU上切换时造成资源的浪费，反而会更慢。即原因是一个进程只存在一把gil锁，当在执行多个线程时，内部会争抢gil锁，这会造成当某一个线程没有抢到锁的时候会让cpu等待，进而不能合理利用多核cpu资源。</p><h1 id="四-协程"><a href="#四-协程" class="headerlink" title="四.协程"></a>四.协程</h1><h3 id="1-协程是什么？"><a href="#1-协程是什么？" class="headerlink" title="1.协程是什么？"></a>1.协程是什么？</h3><p>协程是单线程下的并发，一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。</p><h3 id="2-注意："><a href="#2-注意：" class="headerlink" title="2.注意："></a>2.注意：</h3><ol><li>python的线程属于<strong>内核级别</strong>的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</li><li>单线程内开启协程，一旦遇到io，就会从<strong>应用程序级别</strong>（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</li><li>操作系统控制线程的切换，用户在单线程内控制协程的切换</li></ol><h3 id="3-优点与缺点："><a href="#3-优点与缺点：" class="headerlink" title="3.优点与缺点："></a>3.优点与缺点：</h3><p>优点：</p><p>协程的切换开销更小，属于<strong>程序级别</strong>的切换，操作系统完全感知不到，因而更加轻量级，单线程内就可以实现并发的效果，最大限度地利用cpu。</p><p>缺点：</p><p>协程的本质是单线程下，无法利用多核，（可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程）</p><p>协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol><li>必须在只有一个单线程里实现并发</li><li>修改共享数据不需加锁</li><li>用户程序里自己保存多个控制流的上下文栈</li><li>一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制）</li></ol><h1 id="五-IO模型"><a href="#五-IO模型" class="headerlink" title="五.IO模型"></a>五.IO模型</h1><h3 id="1-IO模型介绍"><a href="#1-IO模型介绍" class="headerlink" title="1.IO模型介绍"></a>1.IO模型介绍</h3><p>IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段：</p><div class="code-wrapper"><pre><code class="hljs">1. 等待数据准备    2. 将数据从内核拷贝到进程中</code></pre></div><p><em>不同IO模型的区别就是在两个阶段上各有不同的情况</em></p><p>补充</p><figure class="highlight lasso"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs lasso">#1、输入操作：read、readv、recv、recvfrom、recvmsg共<span class="hljs-number">5</span>个函数，如果会阻塞状态，则会经历wait <span class="hljs-built_in">data</span>和copy <span class="hljs-built_in">data</span>两个阶段，如果设置为非阻塞则在wait 不到<span class="hljs-built_in">data</span>时抛出异常<br><br>#2、输出操作：write、writev、send、sendto、sendmsg共<span class="hljs-number">5</span>个函数，在发送缓冲区满了会阻塞在原地，如果设置为非阻塞，则会抛出异常<br><br>#3、接收外来链接：accept，与输入操作类似<br><br>#4、发起外出链接：connect，与输出操作类似<br></code></pre></td></tr></table></figure><h3 id="2-阻塞IO"><a href="#2-阻塞IO" class="headerlink" title="2.阻塞IO"></a>2.阻塞IO</h3><p>默认情况下所有的socket都是阻塞的</p><p><img src="1541176-20190830174158661-1225893158.png" alt="img"></p><p> 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。</p><p>而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了</p><p>除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。</p><p> 一个简单的解决方案：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</span><br></code></pre></td></tr></table></figure><p>  该方案的问题是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。</span><br></code></pre></td></tr></table></figure><p>  改进方案：   </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。</span><br>“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。<br>这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。<br></code></pre></td></tr></table></figure><p>  改进后方案其实也存在着问题：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。</span><br>而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。<br>所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。<br></code></pre></td></tr></table></figure><p><strong>对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。</strong> <strong>总之 </strong></p><p><strong>多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。</strong></p><h3 id="3-非阻塞IO"><a href="#3-非阻塞IO" class="headerlink" title="3.非阻塞IO"></a>3.非阻塞IO</h3><p>可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="1541176-20190830183004918-1384121694.png" alt="img"></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。</p><p>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p><p>可以看到用户进程需要一直主动询问kernel数据准备好了没有，带来的问题就是</p><p>循环调用recv()将大幅度推高CPU占用率，在低配主机下极容易出现卡机情况。</p><p>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p><p> 此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。</p><h3 id="4-多路复用IO"><a href="#4-多路复用IO" class="headerlink" title="4.多路复用IO"></a>4.多路复用IO</h3><p>有些地方也称这种IO方式为<strong>事件驱动IO</strong>。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p><p><img src="1541176-20190830200852057-537476716.png" alt="img"></p><p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br> 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><p><strong>强调：</strong></p><p><strong>1. 如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong></p><p><strong>2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</strong></p><p> <strong><em>结论: select的优势在于可以处理多个连接，不适用于单个连接</em></strong></p><p><strong>select监听fd变化的过程分析：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到； </span><br><span class="hljs-meta">#用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。</span><br></code></pre></td></tr></table></figure><p>  <strong>该模型的优点：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">#相比其他模型，使用<span class="hljs-built_in">select</span>() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。<br></code></pre></td></tr></table></figure><p>  <strong>该模型的缺点：</strong></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">#首先<span class="hljs-keyword">select</span>()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，<span class="hljs-keyword">select</span>()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/<span class="hljs-built_in">dev</span>/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。<br>#其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。<br></code></pre></td></tr></table></figure><h3 id="5-异步IO"><a href="#5-异步IO" class="headerlink" title="5.异步IO"></a>5.异步IO</h3><p><img src="1541176-20190830202143066-249527516.png" alt="img"></p><p> 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p>然后由于不稳定等原因异步IO用的并不多。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>349. 两个数组的交集</title>
    <link href="/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/2020/11/02/349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">题目描述</a></h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,2,1]</span>, nums2 = <span class="hljs-comment">[2,2]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[4,9,5]</span>, nums2 = <span class="hljs-comment">[9,4,9,8,4]</span><br>输出：<span class="hljs-comment">[9,4]</span><br></code></pre></td></tr></table></figure> <span id="more"></span><p><strong>说明：</strong></p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h3><p>c++中集合有基于红黑树的<code>set</code>还有哈希的<code>unordered_set</code>，使用集合可以去除重复。</p><p>将<code>nums1</code>放入哈希表<code>s1</code>中，遍历<code>nums2</code>，若元素在<code>s1</code>中，加入结果集合<code>ans</code>中，最后将其转化为<code>vector</code>。、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s1</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums2) &#123;<br>            <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">find</span>(num) != s1.<span class="hljs-built_in">end</span>()) &#123;<br>                ans.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(ans.begin(), ans.end())</span></span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="排序，双指针"><a href="#排序，双指针" class="headerlink" title="排序，双指针"></a>排序，双指针</h3><p>排序之后利用双指针，注意<strong>加入时去重复</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, n1 = nums1.<span class="hljs-built_in">size</span>(), n2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>            <span class="hljs-comment">// 去重复</span><br>            <span class="hljs-keyword">if</span>(nums1[i]==nums2[j] &amp;&amp; (res.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span> || res.<span class="hljs-built_in">back</span>() != nums1[i])) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>                ++i,++j;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[i] &gt; nums2[j]) &#123;<br>                ++j;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ++i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>哈希</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>哈希</tag>
      
      <tag>LeetCode</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>140. 单词拆分 II</title>
    <link href="/2020/11/01/140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II/"/>
    <url>/2020/11/01/140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/word-break-ii/">题目描述</a></h2><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p><strong>说明：</strong></p><ul><li><p>分隔时可以重复使用字典中的单词。</p></li><li><p>你可以假设字典中没有重复的单词。</p></li></ul><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;catsanddog&quot;</span><br>wordDict = [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>]<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;cats and dog&quot;</span>,<br>  <span class="hljs-string">&quot;cat sand dog&quot;</span><br>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;pineapplepenapple&quot;</span><br>wordDict = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>, <span class="hljs-string">&quot;applepen&quot;</span>, <span class="hljs-string">&quot;pine&quot;</span>, <span class="hljs-string">&quot;pineapple&quot;</span>]<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;pine apple pen apple&quot;</span>,<br>  <span class="hljs-string">&quot;pineapple pen apple&quot;</span>,<br>  <span class="hljs-string">&quot;pine applepen apple&quot;</span><br>]<br><span class="hljs-section">解释: 注意你可以重复使用字典中的单词。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">&quot;catsandog&quot;</span><br>wordDict = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br><span class="hljs-section">输出:</span><br>[]<br></code></pre></td></tr></table></figure><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>判断是否可分用动态规划，求具体解使用回溯。</p><p>与<a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a>思想类似，139题可以使用动态规划的方法，或记忆化搜索。但是此题由于样例特殊，可能出现前半段很多解，后半段无解的情况，例如下面的测试用例会导致运行超时。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-string">&quot;aaaa&quot;</span>,<span class="hljs-string">&quot;aaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaaa&quot;</span>,<span class="hljs-string">&quot;aaaaaaaaaa&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="记忆化搜索-vs-动态规划"><a href="#记忆化搜索-vs-动态规划" class="headerlink" title="记忆化搜索 vs. 动态规划"></a>记忆化搜索 vs. 动态规划</h3><ul><li>暴力搜索会产生很多重复的子问题，记忆化搜索记录搜索结果，再次进入相同的子问题直接返回结果（用空间去换时间，与动态规划类似）。</li><li>记忆化搜索是自顶向下求解，动态规划是自底向上。本题中使用自顶向下的方法将不可拆分的情况自动剪枝，效率优于自底向上的动态规划。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>为了加快判断字符串是否在单词列表中，使用哈希方法<code>unordered_set</code>加快查找。</li><li><code>ans[i]</code>保存以<code>i</code>为开始下标的字符串<code>s</code>构成的单词拆分结果。</li><li><code>seen[i]</code>表示以<code>i</code>为开始下标的字符串<code>s</code>是否被搜索</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; seen;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    unordered_set&lt;string&gt; _set;<br>    <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        seen = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>);<br>        ans = vector&lt;vector&lt;string&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;string&gt;());<br>        <span class="hljs-comment">// 哈希set，快速查找</span><br>        _set = <span class="hljs-built_in">unordered_set</span>(wordDict.<span class="hljs-built_in">begin</span>(), wordDict.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt;= n || seen[index]) <span class="hljs-keyword">return</span>;<br>        seen[index] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// substr(index, length)切割的单词区间为[index, index+length)</span><br>        <span class="hljs-comment">// 要取等号，因为i=n时，全部匹配。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>            <span class="hljs-keyword">auto</span> st = s.<span class="hljs-built_in">substr</span>(index, i - index);<br>            <span class="hljs-comment">// 找到了</span><br>            <span class="hljs-keyword">if</span>(_set.<span class="hljs-built_in">find</span>(st) != _set.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">if</span>(i == n) &#123;<br>                    ans[index].<span class="hljs-built_in">push_back</span>(st);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">backtrack</span>(s, i);<br>                    <span class="hljs-keyword">if</span>(ans[i].<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> sit:ans[i]) &#123;<br>                            ans[index].<span class="hljs-built_in">push_back</span>(st+<span class="hljs-string">&quot; &quot;</span>+sit);<br>                        &#125;<br>                    &#125;   <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
      <category>动态规划</category>
      
      <category>记忆化搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>DP</tag>
      
      <tag>字符串</tag>
      
      <tag>回溯</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>463. 岛屿的周长</title>
    <link href="/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/"/>
    <url>/2020/10/30/463-%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">题目描述</a></h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p> <span id="more"></span><p><strong>示例 :</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入:<br><span class="hljs-comment">[<span class="hljs-comment">[0,1,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,1,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[0,1,0,0]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,1,0,0]</span>]</span><br>输出: 16<br><br>解释: 它的周长是下面图片中的 16 个黄色的边：<br></code></pre></td></tr></table></figure><p><img src="island.png" alt="img"></p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>迭代法，判断每个格子四周的状态。</p></li><li><p>lambda表达式</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">[函数对象参数] (操作符重载函数参数) <span class="hljs-keyword">mutable</span> 或 <span class="hljs-keyword">exception</span> 声明 -&gt; 返回值类型 &#123;函数体&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-&gt; 返回值类型、{函数体}.</p></li></ul><p>详细可以看这篇博客 <a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">C++之Lambda表达式</a></p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = grid.<span class="hljs-built_in">size</span>(), c = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span>(grid[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span> &amp;&amp; grid[x - <span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>) --res;<br>            <span class="hljs-keyword">if</span>(x &lt; r - <span class="hljs-number">1</span> &amp;&amp; grid[x + <span class="hljs-number">1</span>][y]==<span class="hljs-number">1</span>) --res;<br>            <span class="hljs-keyword">if</span>(y &gt; <span class="hljs-number">0</span> &amp;&amp; grid[x][y - <span class="hljs-number">1</span>]==<span class="hljs-number">1</span>) --res;<br>            <span class="hljs-keyword">if</span>(y &lt; c - <span class="hljs-number">1</span> &amp;&amp; grid[x][y + <span class="hljs-number">1</span>]==<span class="hljs-number">1</span>) --res;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; r;++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; c;++j) &#123;<br>                ans += <span class="hljs-built_in">check</span>(i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>模拟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
      <tag>迭代</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142. 环形链表 II</title>
    <link href="/2020/10/29/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"/>
    <url>/2020/10/29/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">题目描述</a></h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul><li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="circularlinkedlist_test2.png" alt="img"></p><img src="/2020/10/29/142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/circularlinkedlist_test2.png" class="" title="This is an image"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="circularlinkedlist_test3.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>使用快慢指针，快指针每次走2步，慢指针每次走1步。</strong><br><strong>1. 如果有环必定会相遇。</strong><br><strong>证明：</strong></p><ul><li>设快指针速度$v<em>{fast}=2$，慢指针速度$v</em>{slow}=1$，行走时间为$t$，两者的距离差为$d$，环的周长为$L$，环之前的路径长度为$S$。</li><li>易见$d=(v<em>{fast}-v</em>{slow})*t=t$，因为$t$的值是连续递增整数，若有环，则必定存在某一时刻$t=L$，即必定相遇。</li></ul><p><strong>2. 相遇时刻慢指针的位置相对于入口走了$L-S$</strong><br><strong>证明：</strong></p><ul><li>慢指针在走$S$到达环入口时，由于快指针速度是慢指针的两倍，因此快指针此时已在环中走了$S$。此时两者都在环中，开始进行追逐，设当前时刻$t=0$。</li><li>因为都在环中，快指针追慢指针，可以认为快指针落后慢指针$L-S$，因此相遇时需要满足$(v<em>{fast}-v</em>{slow})*t=L-S$，即$t=L-S$时相遇，又因为慢指针速度为$1$，因此相遇时慢指针相对于环入口走了$L-S$。</li></ul><p><strong>3. 相遇后慢指针再走$S$即到达环入口</strong></p><ul><li>可以再使用指针<code>t</code>从<code>head</code>开始行进，<code>t</code>和慢指针同步走$S$，两者相遇，相遇位置为环入口。</li></ul><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode *fast, *slow, *t;<br>        fast = slow = t = head;<br>        <span class="hljs-keyword">do</span> &#123;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast &amp;&amp; fast-&gt;next)<br>                fast = fast-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            slow = slow-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <span class="hljs-keyword">while</span>(t!=slow) &#123;<br>            t = t-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1529. 灯泡开关 IV</title>
    <link href="/2020/10/29/1529-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-IV/"/>
    <url>/2020/10/29/1529-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3-IV/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/bulb-switcher-iv/">题目描述</a></h2><p>房间中有 <code>n</code> 个灯泡，编号从 <code>0</code> 到 <code>n-1</code> ，自左向右排成一行。最开始的时候，所有的灯泡都是 <strong>关</strong> 着的。</p><p>请你设法使得灯泡的开关状态和 <code>target</code> 描述的状态一致，其中 <code>target[i]</code> 等于 <code>1</code> 第 <code>i</code> 个灯泡是开着的，等于 <code>0</code> 意味着第 <code>i</code> 个灯是关着的。</p><p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p><ul><li>选择当前配置下的任意一个灯泡（下标为 <code>i</code> ）</li><li>翻转下标从 <code>i</code> 到 <code>n-1</code> 的每个灯泡</li></ul><p>翻转时，如果灯泡的状态为 <code>0</code> 就变为 <code>1</code>，为 <code>1</code> 就变为 <code>0</code> 。</p><p>返回达成 <code>target</code> 描述的状态所需的 <strong>最少</strong> 翻转次数。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs clean">输入：target = <span class="hljs-string">&quot;10111&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：初始配置 <span class="hljs-string">&quot;00000&quot;</span>.<br>从第 <span class="hljs-number">3</span> 个灯泡（下标为 <span class="hljs-number">2</span>）开始翻转 <span class="hljs-string">&quot;00000&quot;</span> -&gt; <span class="hljs-string">&quot;00111&quot;</span><br>从第 <span class="hljs-number">1</span> 个灯泡（下标为 <span class="hljs-number">0</span>）开始翻转 <span class="hljs-string">&quot;00111&quot;</span> -&gt; <span class="hljs-string">&quot;11000&quot;</span><br>从第 <span class="hljs-number">2</span> 个灯泡（下标为 <span class="hljs-number">1</span>）开始翻转 <span class="hljs-string">&quot;11000&quot;</span> -&gt; <span class="hljs-string">&quot;10111&quot;</span><br>至少需要翻转 <span class="hljs-number">3</span> 次才能达成 target 描述的状态<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：target = <span class="hljs-string">&quot;101&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-string">&quot;000&quot;</span> -&gt; <span class="hljs-string">&quot;111&quot;</span> -&gt; <span class="hljs-string">&quot;100&quot;</span> -&gt; <span class="hljs-string">&quot;101&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：target <span class="hljs-operator">=</span> <span class="hljs-string">&quot;00000&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：target <span class="hljs-operator">=</span> <span class="hljs-string">&quot;001011101&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>target[i] == &#39;0&#39;</code> 或者 <code>target[i] == &#39;1&#39;</code></li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>$dp[i][0]$表示从第<code>i</code>个灯泡到末尾转换为和目标状态相同的需要的次数，$0\leq i &lt; n$</li><li>$dp[i][1]$表示从第<code>i</code>个灯泡到末尾转换为和目标状态相反的需要的次数，$0\leq i &lt; n$<br>状态转移方程<script type="math/tex; mode=display">dp[i][0] = \begin {cases}dp[i+1][0],&\text{target[i]='0'} \\dp[i+1][1]+1,&\text{target[i]='1'}\end{cases}</script><script type="math/tex; mode=display">dp[i][1] = \begin {cases}dp[i+1][0]+1,&\text{target[i]='0'} \\dp[i+1][1],&\text{target[i]='1'}\end{cases}</script><script type="math/tex; mode=display">dp[n][0] = dp[n][1] = 0</script></li></ul><h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minFlips</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        dp = [[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(target)+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(target)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># print(i,end = &#x27;,&#x27;)</span><br>            <span class="hljs-keyword">if</span> target[i] == <span class="hljs-string">&#x27;0&#x27;</span>:<br>                dp[i][<span class="hljs-number">0</span>] = dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>                dp[i][<span class="hljs-number">1</span>] = dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i][<span class="hljs-number">0</span>] = dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[i][<span class="hljs-number">1</span>] = dp[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCP 25. 古董键盘</title>
    <link href="/2020/10/29/LCP-25-%E5%8F%A4%E8%91%A3%E9%94%AE%E7%9B%98/"/>
    <url>/2020/10/29/LCP-25-%E5%8F%A4%E8%91%A3%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://leetcode-cn.com/problems/Uh984O/">题目描述</a></h2><p>小扣在秋日市集购买了一个古董键盘。由于古董键盘年久失修，键盘上只有 26 个字母 <strong>a~z</strong> 可以按下，且每个字母最多仅能被按 <code>k</code> 次。</p><p>小扣随机按了 <code>n</code> 次按键，请返回小扣总共有可能按出多少种内容。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。</p><span id="more"></span><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>k = 1, n = 1</code></p><p>输出：<code>26</code></p><p>解释：由于只能按一次按键，所有可能的字符串为 “a”, “b”, … “z”</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>k = 1, n = 2</code></p><p>输出：<code>650</code></p><p>解释：由于只能按两次按键，且每个键最多只能按一次，所有可能的字符串（按字典序排序）为 “ab”, “ac”, … “zy”</p></blockquote><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= k &lt;= 5</code></p></li><li><p><code>1 &lt;= n &lt;= 26*k</code></p></li></ul><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>$dp[i][j]$表示总长度为$i$，用了前$j$种字母可能出现的字符串的数量，可以得到如下转移方程。</p><script type="math/tex; mode=display">dp[i][j]=\sum_{x=0}^kdp[i-x][j-1]·C_i^x</script><p>其中，$x$表示第$j$种字母出现的次数，其值可以为$0,1,..k$，对于每一个$x$，都有$C_i^x$种位置可以选择。<br>例如，$x=2$，表示第$j$种字符出现了$2$次，他可能出现在前$i$个位置中的任意两个，是一个组合问题，其结果是$C_i^2$。</p><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">keyboard</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(<span class="hljs-number">27</span>, <span class="hljs-number">0L</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">26</span>;i++)<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= <span class="hljs-number">26</span>;j++) &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;x &lt;= k;x++) &#123;<br>                    <span class="hljs-keyword">if</span>(i-x &gt;= <span class="hljs-number">0</span>)<br>                    dp[i][j] += dp[i-x][j<span class="hljs-number">-1</span>]*<span class="hljs-built_in">C</span>(i,x);<br>                &#125;<br>                dp[i][j] %=  <span class="hljs-number">1000000007</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">26</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &lt;= n) &#123;<br>            ans=((m-k+<span class="hljs-number">1</span>)*ans)/k;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
